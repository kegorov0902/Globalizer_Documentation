<!DOCTYPE html>

<html lang="ru" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Globalizer: Testing Reference &#8212; документация Globalizer 141025</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=799f848e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cd1d70c9"></script>
    <link rel="index" title="Алфавитный указатель" href="../genindex.html" />
    <link rel="search" title="Поиск" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="testing-reference">
<h1>Testing Reference<a class="headerlink" href="#testing-reference" title="Ссылка на этот заголовок">¶</a></h1>
<div class="doxygen-content docutils container">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Globalizer: Testing Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Globalizer<span id="projectnumber">&#160;1.1</span>
   </div>
   <div id="projectbrief">Exascale Minimizer - параллельная программная система для решения задач глобальной оптимизации</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Поиск',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Testing Reference </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md704"></a></p>
<p>This page lists the facilities provided by GoogleTest for writing test programs. To use them, add <span class="tt">#include &lt;gtest/gtest.h&gt;</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md705"></a>
Macros</h1>
<p>GoogleTest defines the following macros for writing tests.</p>
<h2 class="doxsection"><a class="anchor" id="TEST"></a>
TEST</h2>
<pre>
TEST(<em>TestSuiteName</em>, <em>TestName</em>) {
  ... <em>statements</em> ...
}
</pre><p>Defines an individual test named <em><span class="tt">TestName</span></em> in the test suite <em><span class="tt">TestSuiteName</span></em>, consisting of the given statements.</p>
<p>Both arguments <em><span class="tt">TestSuiteName</span></em> and <em><span class="tt">TestName</span></em> must be valid C++ identifiers and must not contain underscores (<span class="tt">_</span>). Tests in different test suites can have the same individual name.</p>
<p>The statements within the test body can be any code under test. <a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2assertions.html">Assertions</a> used within the test body determine the outcome of the test.</p>
<h2 class="doxsection"><a class="anchor" id="TEST_F"></a>
TEST_F</h2>
<pre>
TEST_F(<em>TestFixtureName</em>, <em>TestName</em>) {
  ... <em>statements</em> ...
}
</pre><p>Defines an individual test named <em><span class="tt">TestName</span></em> that uses the test fixture class <em><span class="tt">TestFixtureName</span></em>. The test suite name is <em><span class="tt">TestFixtureName</span></em>.</p>
<p>Both arguments <em><span class="tt">TestFixtureName</span></em> and <em><span class="tt">TestName</span></em> must be valid C++ identifiers and must not contain underscores (<span class="tt">_</span>). <em><span class="tt">TestFixtureName</span></em> must be the name of a test fixture class—see <a href="../primer.md#same-data-multiple-tests">Test Fixtures</a>.</p>
<p>The statements within the test body can be any code under test. <a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2assertions.html">Assertions</a> used within the test body determine the outcome of the test.</p>
<h2 class="doxsection"><a class="anchor" id="TEST_P"></a>
TEST_P</h2>
<pre>
TEST_P(<em>TestFixtureName</em>, <em>TestName</em>) {
  ... <em>statements</em> ...
}
</pre><p>Defines an individual value-parameterized test named <em><span class="tt">TestName</span></em> that uses the test fixture class <em><span class="tt">TestFixtureName</span></em>. The test suite name is <em><span class="tt">TestFixtureName</span></em>.</p>
<p>Both arguments <em><span class="tt">TestFixtureName</span></em> and <em><span class="tt">TestName</span></em> must be valid C++ identifiers and must not contain underscores (<span class="tt">_</span>). <em><span class="tt">TestFixtureName</span></em> must be the name of a value-parameterized test fixture class—see <a href="../advanced.md#value-parameterized-tests">Value-Parameterized Tests</a>.</p>
<p>The statements within the test body can be any code under test. Within the test body, the test parameter can be accessed with the <span class="tt">GetParam()</span> function (see <a class="el" href="#WithParamInterface">`WithParamInterface`</a>). For example:</p>
<div class="fragment"><div class="line">TEST_P(MyTestSuite, DoesSomething) {</div>
<div class="line">  ...</div>
<div class="line">  EXPECT_TRUE(DoSomething(GetParam()));</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2assertions.html">Assertions</a> used within the test body determine the outcome of the test.</p>
<p>See also <a class="el" href="#INSTANTIATE_TEST_SUITE_P">`INSTANTIATE_TEST_SUITE_P`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="INSTANTIATE_TEST_SUITE_P"></a>
INSTANTIATE_TEST_SUITE_P</h2>
<p><span class="tt">INSTANTIATE_TEST_SUITE_P(</span>*<span class="tt">InstantiationName</span>*<span class="tt">,</span>*<span class="tt">TestSuiteName</span>*<span class="tt">,</span>*<span class="tt">param_generator</span>*<span class="tt">)</span> \ <span class="tt">INSTANTIATE_TEST_SUITE_P(</span>*<span class="tt">InstantiationName</span>*<span class="tt">,</span>*<span class="tt">TestSuiteName</span>*<span class="tt">,</span>*<span class="tt">param_generator</span>*<span class="tt">,</span>*<span class="tt">name_generator</span>*<span class="tt">)</span></p>
<p>Instantiates the value-parameterized test suite <em><span class="tt">TestSuiteName</span></em> (defined with <a class="el" href="#TEST_P">`TEST_P`</a>).</p>
<p>The argument <em><span class="tt">InstantiationName</span></em> is a unique name for the instantiation of the test suite, to distinguish between multiple instantiations. In test output, the instantiation name is added as a prefix to the test suite name <em><span class="tt">TestSuiteName</span></em>. If <em><span class="tt">InstantiationName</span></em> is empty (<span class="tt">INSTANTIATE_TEST_SUITE_P(, ...)</span>), no prefix is added.</p>
<p>The argument <em><span class="tt">param_generator</span></em> is one of the following GoogleTest-provided functions that generate the test parameters, all defined in the <span class="tt">::testing</span> namespace:</p>
<p><span id="param-generators"></span></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter Generator  </th><th class="markdownTableHeadNone">Behavior  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Range(begin, end [, step])</span>  </td><td class="markdownTableBodyNone">Yields values <span class="tt">{begin, begin+step, begin+step+step, ...}</span>. The values do not include <span class="tt">end</span>. <span class="tt">step</span> defaults to 1.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Values(v1, v2, ..., vN)</span>  </td><td class="markdownTableBodyNone">Yields values <span class="tt">{v1, v2, ..., vN}</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">ValuesIn(container)</span> or <span class="tt">ValuesIn(begin,end)</span>  </td><td class="markdownTableBodyNone">Yields values from a C-style array, an STL-style container, or an iterator range <span class="tt">[begin, end)</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Bool()</span>  </td><td class="markdownTableBodyNone">Yields sequence <span class="tt">{false, true}</span>.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Combine(g1, g2, ..., gN)</span>  </td><td class="markdownTableBodyNone">Yields as <span class="tt">std::tuple</span> <em>n</em>-tuples all combinations (Cartesian product) of the values generated by the given <em>n</em> generators <span class="tt">g1</span>, <span class="tt">g2</span>, ..., <span class="tt">gN</span>.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">ConvertGenerator&lt;T&gt;(g)</span> or <span class="tt">ConvertGenerator(g, func)</span>  </td><td class="markdownTableBodyNone">Yields values generated by generator <span class="tt">g</span>, <span class="tt">static_cast</span> from <span class="tt">T</span>. (Note: <span class="tt">T</span> might not be what you expect. See *Using ConvertGenerator* below.) The second overload uses <span class="tt">func</span> to perform the conversion.  </td></tr>
</table>
<p>The optional last argument <em><span class="tt">name_generator</span></em> is a function or functor that generates custom test name suffixes based on the test parameters. The function must accept an argument of type <a class="el" href="#TestParamInfo">`TestParamInfo&lt;class ParamType&gt;`</a> and return a <span class="tt">std::string</span>. The test name suffix can only contain alphanumeric characters and underscores. GoogleTest provides <a class="el" href="#PrintToStringParamName">`PrintToStringParamName`</a>, or a custom function can be used for more control:</p>
<div class="fragment"><div class="line">INSTANTIATE_TEST_SUITE_P(</div>
<div class="line">    MyInstantiation, MyTestSuite,</div>
<div class="line">    testing::Values(...),</div>
<div class="line">    [](<span class="keyword">const</span> <a class="code hl_struct" href="structtesting_1_1_test_param_info.html">testing::TestParamInfo&lt;MyTestSuite::ParamType&gt;</a>&amp; info) {</div>
<div class="line">      <span class="comment">// Can use info.param here to generate the test suffix</span></div>
<div class="line">      std::string name = ...</div>
<div class="line">      <span class="keywordflow">return</span> name;</div>
<div class="line">    });</div>
<div class="ttc" id="astructtesting_1_1_test_param_info_html"><div class="ttname"><a href="structtesting_1_1_test_param_info.html">testing::TestParamInfo</a></div><div class="ttdef"><b>Определения</b> gtest-param-util.h:64</div></div>
</div><!-- fragment --><p>For more information, see <a href="../advanced.md#value-parameterized-tests">Value-Parameterized Tests</a>.</p>
<p>See also <a class="el" href="#GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST">`GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST`</a>.</p>
<h5 class="doxsection"><a class="anchor" id="autotoc_md706"></a>
Using <span class="tt">ConvertGenerator</span></h5>
<p>The functions listed in the table above appear to return generators that create values of the desired types, but this is not generally the case. Rather, they typically return factory objects that convert to the the desired generators. This affords some flexibility in allowing you to specify values of types that are different from, yet implicitly convertible to, the actual parameter type required by your fixture class.</p>
<p>For example, you can do the following with a fixture that requires an <span class="tt">int</span> parameter:</p>
<div class="fragment"><div class="line">INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTestSuite,</div>
<div class="line">    testing::Values(1, 1.2));  <span class="comment">// Yes, Values() supports heterogeneous argument types.</span></div>
</div><!-- fragment --><p>It might seem obvious that <span class="tt">1.2</span> &mdash; a <span class="tt">double</span> &mdash; will be converted to an <span class="tt">int</span> but in actuality it requires some template gymnastics involving the indirection described in the previous paragraph.</p>
<p>What if your parameter type is not implicitly convertible from the generated type but is <em>explicitly</em> convertible? There will be no automatic conversion, but you can force it by applying <span class="tt">ConvertGenerator&lt;T&gt;</span>. The compiler can automatically deduce the target type (your fixture's parameter type), but because of the aforementioned indirection it cannot decide what the generated type should be. You need to tell it, by providing the type <span class="tt">T</span> explicitly. Thus <span class="tt">T</span> should not be your fixture's parameter type, but rather an intermediate type that is supported by the factory object, and which can be <span class="tt">static_cast</span> to the fixture's parameter type:</p>
<div class="fragment"><div class="line"><span class="comment">// The fixture&#39;s parameter type.</span></div>
<div class="line"><span class="keyword">class </span>MyParam {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Explicit converting ctor.</span></div>
<div class="line">  <span class="keyword">explicit</span> MyParam(<span class="keyword">const</span> std::tuple&lt;int, bool&gt;&amp; t);</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTestSuite,</div>
<div class="line">    ConvertGenerator&lt;std::tuple&lt;int, bool&gt;&gt;(Combine(Values(0.1, 1.2), <a class="code hl_struct" href="struct_bool.html">Bool</a>())));</div>
<div class="ttc" id="astruct_bool_html"><div class="ttname"><a href="struct_bool.html">Bool</a></div><div class="ttdef"><b>Определения</b> gtest_pred_impl_unittest.cc:54</div></div>
</div><!-- fragment --><p>In this example <span class="tt">Combine</span> supports the generation of <span class="tt">std::tuple&lt;int, bool&gt;&gt;</span> objects (even though the provided values for the first tuple element are <span class="tt">double</span>s) and those <span class="tt">tuple</span>s get converted into <span class="tt">MyParam</span> objects by virtue of the call to <span class="tt">ConvertGenerator</span>.</p>
<p>For parameter types that are not convertible from the generated types you can provide a callable that does the conversion. The callable accepts an object of the generated type and returns an object of the fixture's parameter type. The generated type can often be deduced by the compiler from the callable's call signature so you do not usually need specify it explicitly (but see a caveat below).</p>
<div class="fragment"><div class="line"><span class="comment">// The fixture&#39;s parameter type.</span></div>
<div class="line"><span class="keyword">class </span>MyParam {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyParam(<span class="keywordtype">int</span>, <span class="keywordtype">bool</span>);</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTestSuite,</div>
<div class="line">    ConvertGenerator(Combine(Values(1, 1.2), <a class="code hl_struct" href="struct_bool.html">Bool</a>()),</div>
<div class="line">        [](<span class="keyword">const</span> std::tuple&lt;int, bool&gt;&amp; t){</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> [i, b] = t;</div>
<div class="line">          <span class="keywordflow">return</span> MyParam(i, b);</div>
<div class="line">        }));</div>
</div><!-- fragment --><p>The callable may be anything that can be used to initialize a <span class="tt">std::function</span> with the appropriate call signature. Note the callable's return object gets <span class="tt">static_cast</span> to the fixture's parameter type, so it does not have to be of that exact type, only convertible to it.</p>
<p><b>Caveat:</b> Consider the following example.</p>
<div class="fragment"><div class="line">INSTANTIATE_TEST_SUITE_P(MyInstantiation, MyTestSuite,</div>
<div class="line">    ConvertGenerator(Values(std::string(<span class="stringliteral">&quot;s&quot;</span>)), [](std::string_view s) { ... }));</div>
</div><!-- fragment --><p>The <span class="tt">string</span> argument gets copied into the factory object returned by <span class="tt">Values</span>. Then, because the generated type deduced from the lambda is <span class="tt">string_view</span>, the factory object spawns a generator that holds a <span class="tt">string_view</span> referencing that <span class="tt">string</span>. Unfortunately, by the time this generator gets invoked, the factory object is gone and the <span class="tt">string_view</span> is dangling.</p>
<p>To overcome this problem you can specify the generated type explicitly: <span class="tt">ConvertGenerator&lt;std::string&gt;(Values(std::string("s")), [](std::string_view s)
{ ... })</span>. Alternatively, you can change the lambda's signature to take a <span class="tt">std::string</span> or a <span class="tt">const std::string&amp;</span> (the latter will not leave you with a dangling reference because the type deduction strips off the reference and the <span class="tt">const</span>).</p>
<h2 class="doxsection"><a class="anchor" id="TYPED_TEST_SUITE"></a>
TYPED_TEST_SUITE</h2>
<p><span class="tt">TYPED_TEST_SUITE(</span>*<span class="tt">TestFixtureName</span>*<span class="tt">,</span>*<span class="tt">Types</span>*<span class="tt">)</span> <span class="tt">TYPED_TEST_SUITE(</span>*<span class="tt">TestFixtureName</span>*<span class="tt">,</span>*<span class="tt">Types</span>*<span class="tt">,</span>*<span class="tt">NameGenerator</span>*<span class="tt">)</span></p>
<p>Defines a typed test suite based on the test fixture <em><span class="tt">TestFixtureName</span></em>. The test suite name is <em><span class="tt">TestFixtureName</span></em>.</p>
<p>The argument <em><span class="tt">TestFixtureName</span></em> is a fixture class template, parameterized by a type, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>MyFixture : <span class="keyword">public</span> <a class="code hl_class" href="classtesting_1_1_test.html">testing::Test</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">using </span>List = std::list&lt;T&gt;;</div>
<div class="line">  <span class="keyword">static</span> T shared_;</div>
<div class="line">  T value_;</div>
<div class="line">};</div>
<div class="ttc" id="aclasstesting_1_1_test_html"><div class="ttname"><a href="classtesting_1_1_test.html">testing::Test</a></div><div class="ttdef"><b>Определения</b> gtest.h:242</div></div>
</div><!-- fragment --><p>The argument <em><span class="tt">Types</span></em> is a <a class="el" href="#Types">`Types`</a> object representing the list of types to run the tests on, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>MyTypes = ::testing::Types&lt;char, int, unsigned int&gt;;</div>
<div class="line">TYPED_TEST_SUITE(MyFixture, MyTypes);</div>
</div><!-- fragment --><p>The type alias (<span class="tt">using</span> or <span class="tt">typedef</span>) is necessary for the <span class="tt">TYPED_TEST_SUITE</span> macro to parse correctly.</p>
<p>The optional third argument <em><span class="tt">NameGenerator</span></em> allows specifying a class that exposes a templated static function <span class="tt">GetName(int)</span>. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NameGenerator {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">static</span> std::string GetName(<span class="keywordtype">int</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, char&gt;) <span class="keywordflow">return</span> <span class="stringliteral">&quot;char&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, int&gt;) <span class="keywordflow">return</span> <span class="stringliteral">&quot;int&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, unsigned int&gt;) <span class="keywordflow">return</span> <span class="stringliteral">&quot;unsignedInt&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">TYPED_TEST_SUITE(MyFixture, MyTypes, NameGenerator);</div>
</div><!-- fragment --><p>See also <a class="el" href="#TYPED_TEST">`TYPED_TEST`</a> and <a href="../advanced.md#typed-tests">Typed Tests</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="TYPED_TEST"></a>
TYPED_TEST</h2>
<pre>
TYPED_TEST(<em>TestSuiteName</em>, <em>TestName</em>) {
  ... <em>statements</em> ...
}
</pre><p>Defines an individual typed test named <em><span class="tt">TestName</span></em> in the typed test suite <em><span class="tt">TestSuiteName</span></em>. The test suite must be defined with <a class="el" href="#TYPED_TEST_SUITE">`TYPED_TEST_SUITE`</a>.</p>
<p>Within the test body, the special name <span class="tt">TypeParam</span> refers to the type parameter, and <span class="tt">TestFixture</span> refers to the fixture class. See the following example:</p>
<div class="fragment"><div class="line">TYPED_TEST(MyFixture, Example) {</div>
<div class="line">  <span class="comment">// Inside a test, refer to the special name TypeParam to get the type</span></div>
<div class="line">  <span class="comment">// parameter.  Since we are inside a derived class template, C++ requires</span></div>
<div class="line">  <span class="comment">// us to visit the members of MyFixture via &#39;this&#39;.</span></div>
<div class="line">  TypeParam n = this-&gt;value_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// To visit static members of the fixture, add the &#39;TestFixture::&#39;</span></div>
<div class="line">  <span class="comment">// prefix.</span></div>
<div class="line">  n += TestFixture::shared_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// To refer to typedefs in the fixture, add the &#39;typename TestFixture::&#39;</span></div>
<div class="line">  <span class="comment">// prefix. The &#39;typename&#39; is required to satisfy the compiler.</span></div>
<div class="line">  <span class="keyword">typename</span> TestFixture::List values;</div>
<div class="line"> </div>
<div class="line">  values.push_back(n);</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>For more information, see <a href="../advanced.md#typed-tests">Typed Tests</a>.</p>
<h2 class="doxsection"><a class="anchor" id="TYPED_TEST_SUITE_P"></a>
TYPED_TEST_SUITE_P</h2>
<p><span class="tt">TYPED_TEST_SUITE_P(</span>*<span class="tt">TestFixtureName</span>*<span class="tt">)</span></p>
<p>Defines a type-parameterized test suite based on the test fixture <em><span class="tt">TestFixtureName</span></em>. The test suite name is <em><span class="tt">TestFixtureName</span></em>.</p>
<p>The argument <em><span class="tt">TestFixtureName</span></em> is a fixture class template, parameterized by a type. See <a class="el" href="#TYPED_TEST_SUITE">`TYPED_TEST_SUITE`</a> for an example.</p>
<p>See also <a class="el" href="#TYPED_TEST_P">`TYPED_TEST_P`</a> and <a href="../advanced.md#type-parameterized-tests">Type-Parameterized Tests</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="TYPED_TEST_P"></a>
TYPED_TEST_P</h2>
<pre>
TYPED_TEST_P(<em>TestSuiteName</em>, <em>TestName</em>) {
  ... <em>statements</em> ...
}
</pre><p>Defines an individual type-parameterized test named <em><span class="tt">TestName</span></em> in the type-parameterized test suite <em><span class="tt">TestSuiteName</span></em>. The test suite must be defined with <a class="el" href="#TYPED_TEST_SUITE_P">`TYPED_TEST_SUITE_P`</a>.</p>
<p>Within the test body, the special name <span class="tt">TypeParam</span> refers to the type parameter, and <span class="tt">TestFixture</span> refers to the fixture class. See <a class="el" href="#TYPED_TEST">`TYPED_TEST`</a> for an example.</p>
<p>See also <a class="el" href="#REGISTER_TYPED_TEST_SUITE_P">`REGISTER_TYPED_TEST_SUITE_P`</a> and <a href="../advanced.md#type-parameterized-tests">Type-Parameterized Tests</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="REGISTER_TYPED_TEST_SUITE_P"></a>
REGISTER_TYPED_TEST_SUITE_P</h2>
<p><span class="tt">REGISTER_TYPED_TEST_SUITE_P(</span>*<span class="tt">TestSuiteName</span>*<span class="tt">,</span>*<span class="tt">TestNames...</span>*<span class="tt">)</span></p>
<p>Registers the type-parameterized tests <em><span class="tt">TestNames...</span></em> of the test suite <em><span class="tt">TestSuiteName</span></em>. The test suite and tests must be defined with <a class="el" href="#TYPED_TEST_SUITE_P">`TYPED_TEST_SUITE_P`</a> and <a class="el" href="#TYPED_TEST_P">`TYPED_TEST_P`</a>.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Define the test suite and tests.</span></div>
<div class="line">TYPED_TEST_SUITE_P(MyFixture);</div>
<div class="line">TYPED_TEST_P(MyFixture, HasPropertyA) { ... }</div>
<div class="line">TYPED_TEST_P(MyFixture, HasPropertyB) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register the tests in the test suite.</span></div>
<div class="line">REGISTER_TYPED_TEST_SUITE_P(MyFixture, HasPropertyA, HasPropertyB);</div>
</div><!-- fragment --><p>See also <a class="el" href="#INSTANTIATE_TYPED_TEST_SUITE_P">`INSTANTIATE_TYPED_TEST_SUITE_P`</a> and <a href="../advanced.md#type-parameterized-tests">Type-Parameterized Tests</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="INSTANTIATE_TYPED_TEST_SUITE_P"></a>
INSTANTIATE_TYPED_TEST_SUITE_P</h2>
<p><span class="tt">INSTANTIATE_TYPED_TEST_SUITE_P(</span>*<span class="tt">InstantiationName</span>*<span class="tt">,</span>*<span class="tt">TestSuiteName</span>*<span class="tt">,</span>*<span class="tt">Types</span>*<span class="tt">)</span></p>
<p>Instantiates the type-parameterized test suite <em><span class="tt">TestSuiteName</span></em>. The test suite must be registered with <a class="el" href="#REGISTER_TYPED_TEST_SUITE_P">`REGISTER_TYPED_TEST_SUITE_P`</a>.</p>
<p>The argument <em><span class="tt">InstantiationName</span></em> is a unique name for the instantiation of the test suite, to distinguish between multiple instantiations. In test output, the instantiation name is added as a prefix to the test suite name <em><span class="tt">TestSuiteName</span></em>. If <em><span class="tt">InstantiationName</span></em> is empty (<span class="tt">INSTANTIATE_TYPED_TEST_SUITE_P(, ...)</span>), no prefix is added.</p>
<p>The argument <em><span class="tt">Types</span></em> is a <a class="el" href="#Types">`Types`</a> object representing the list of types to run the tests on, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>MyTypes = ::testing::Types&lt;char, int, unsigned int&gt;;</div>
<div class="line">INSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyFixture, MyTypes);</div>
</div><!-- fragment --><p>The type alias (<span class="tt">using</span> or <span class="tt">typedef</span>) is necessary for the <span class="tt">INSTANTIATE_TYPED_TEST_SUITE_P</span> macro to parse correctly.</p>
<p>For more information, see <a href="../advanced.md#type-parameterized-tests">Type-Parameterized Tests</a>.</p>
<h2 class="doxsection"><a class="anchor" id="FRIEND_TEST"></a>
FRIEND_TEST</h2>
<p><span class="tt">FRIEND_TEST(</span>*<span class="tt">TestSuiteName</span>*<span class="tt">,</span>*<span class="tt">TestName</span>*<span class="tt">)</span></p>
<p>Within a class body, declares an individual test as a friend of the class, enabling the test to access private class members.</p>
<p>If the class is defined in a namespace, then in order to be friends of the class, test fixtures and tests must be defined in the exact same namespace, without inline or anonymous namespaces.</p>
<p>For example, if the class definition looks like the following:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>my_namespace {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyClass {</div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>MyClassTest;</div>
<div class="line">  FRIEND_TEST(MyClassTest, HasPropertyA);</div>
<div class="line">  FRIEND_TEST(MyClassTest, HasPropertyB);</div>
<div class="line">  ... definition of <span class="keyword">class </span>MyClass ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace my_namespace</span></div>
</div><!-- fragment --><p>Then the test code should look like:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>my_namespace {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyClassTest : <span class="keyword">public</span> <a class="code hl_class" href="classtesting_1_1_test.html">testing::Test</a> {</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">TEST_F(MyClassTest, HasPropertyA) { ... }</div>
<div class="line">TEST_F(MyClassTest, HasPropertyB) { ... }</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace my_namespace</span></div>
</div><!-- fragment --><p>See <a href="../advanced.md#testing-private-code">Testing Private Code</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="SCOPED_TRACE"></a>
SCOPED_TRACE</h2>
<p><span class="tt">SCOPED_TRACE(</span>*<span class="tt">message</span>*<span class="tt">)</span></p>
<p>Causes the current file name, line number, and the given message <em><span class="tt">message</span></em> to be added to the failure message for each assertion failure that occurs in the scope.</p>
<p>For more information, see <a href="../advanced.md#adding-traces-to-assertions">Adding Traces to Assertions</a>.</p>
<p>See also the <a class="el" href="#ScopedTrace">`ScopedTrace` class</a>.</p>
<h2 class="doxsection"><a class="anchor" id="GTEST_SKIP"></a>
GTEST_SKIP</h2>
<p><span class="tt">GTEST_SKIP()</span></p>
<p>Prevents further test execution at runtime.</p>
<p>Can be used in individual test cases or in the <span class="tt">SetUp()</span> methods of test environments or test fixtures (classes derived from the <a class="el" href="#Environment">`Environment`</a> or <a class="el" href="#Test">`Test`</a> classes). If used in a global test environment <span class="tt">SetUp()</span> method, it skips all tests in the test program. If used in a test fixture <span class="tt">SetUp()</span> method, it skips all tests in the corresponding test suite.</p>
<p>Similar to assertions, <span class="tt">GTEST_SKIP</span> allows streaming a custom message into it.</p>
<p>See <a href="../advanced.md#skipping-test-execution">Skipping Test Execution</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST"></a>
GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST</h2>
<p><span class="tt">GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(</span>*<span class="tt">TestSuiteName</span>*<span class="tt">)</span></p>
<p>Allows the value-parameterized test suite <em><span class="tt">TestSuiteName</span></em> to be uninstantiated.</p>
<p>By default, every <a class="el" href="#TEST_P">`TEST_P`</a> call without a corresponding <a class="el" href="#INSTANTIATE_TEST_SUITE_P">`INSTANTIATE_TEST_SUITE_P`</a> call causes a failing test in the test suite <span class="tt">GoogleTestVerification</span>. <span class="tt">GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST</span> suppresses this failure for the given test suite.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md707"></a>
Classes and types</h1>
<p>GoogleTest defines the following classes and types to help with writing tests.</p>
<h2 class="doxsection"><a class="anchor" id="AssertionResult"></a>
AssertionResult</h2>
<p><span class="tt">testing::AssertionResult</span></p>
<p>A class for indicating whether an assertion was successful.</p>
<p>When the assertion wasn't successful, the <span class="tt">AssertionResult</span> object stores a non-empty failure message that can be retrieved with the object's <span class="tt">message()</span> method.</p>
<p>To create an instance of this class, use one of the factory functions <a class="el" href="#AssertionSuccess">`AssertionSuccess()`</a> or <a class="el" href="#AssertionFailure">`AssertionFailure()`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="AssertionException"></a>
AssertionException</h2>
<p><span class="tt">testing::AssertionException</span></p>
<p><a class="el" href="class_exception.html">Exception</a> which can be thrown from `TestEventListener::OnTestPartResult`.</p>
<h2 class="doxsection"><a class="anchor" id="EmptyTestEventListener"></a>
EmptyTestEventListener</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_empty_test_event_listener.html">testing::EmptyTestEventListener</a></span></p>
<p>Provides an empty implementation of all methods in the <a class="el" href="#TestEventListener">`TestEventListener`</a> interface, such that a subclass only needs to override the methods it cares about.</p>
<h2 class="doxsection"><a class="anchor" id="Environment"></a>
Environment</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_environment.html">testing::Environment</a></span></p>
<p>Represents a global test environment. See <a href="../advanced.md#global-set-up-and-tear-down">Global Set-Up and Tear-Down</a>.</p>
<h3 class="doxsection"><a class="anchor" id="Environment-protected"></a>
Protected Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md708"></a>
SetUp {#Environment::SetUp}</h4>
<p><span class="tt">virtual void Environment::SetUp()</span></p>
<p>Override this to define how to set up the environment.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md709"></a>
TearDown {#Environment::TearDown}</h4>
<p><span class="tt">virtual void Environment::TearDown()</span></p>
<p>Override this to define how to tear down the environment.</p>
<h2 class="doxsection"><a class="anchor" id="ScopedTrace"></a>
ScopedTrace</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_scoped_trace.html">testing::ScopedTrace</a></span></p>
<p>An instance of this class causes a trace to be included in every test failure message generated by code in the scope of the lifetime of the <span class="tt">ScopedTrace</span> instance. The effect is undone with the destruction of the instance.</p>
<p>The <span class="tt">ScopedTrace</span> constructor has the following form:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">ScopedTrace(<span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">int</span> line, <span class="keyword">const</span> T&amp; message)</div>
</div><!-- fragment --><p>Example usage:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtesting_1_1_scoped_trace.html">testing::ScopedTrace</a> trace(<span class="stringliteral">&quot;file.cc&quot;</span>, 123, <span class="stringliteral">&quot;message&quot;</span>);</div>
<div class="ttc" id="aclasstesting_1_1_scoped_trace_html"><div class="ttname"><a href="classtesting_1_1_scoped_trace.html">testing::ScopedTrace</a></div><div class="ttdef"><b>Определения</b> gtest.h:2074</div></div>
</div><!-- fragment --><p>The resulting trace includes the given source file path and line number, and the given message. The <span class="tt">message</span> argument can be anything streamable to <span class="tt">std::ostream</span>.</p>
<p>See also <a class="el" href="#SCOPED_TRACE">`SCOPED_TRACE`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="Test"></a>
Test</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_test.html">testing::Test</a></span></p>
<p>The abstract class that all tests inherit from. <span class="tt">Test</span> is not copyable.</p>
<h3 class="doxsection"><a class="anchor" id="Test-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md710"></a>
SetUpTestSuite {#Test::SetUpTestSuite}</h4>
<p><span class="tt">static void Test::SetUpTestSuite()</span></p>
<p>Performs shared setup for all tests in the test suite. GoogleTest calls <span class="tt">SetUpTestSuite()</span> before running the first test in the test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md711"></a>
TearDownTestSuite {#Test::TearDownTestSuite}</h4>
<p><span class="tt">static void Test::TearDownTestSuite()</span></p>
<p>Performs shared teardown for all tests in the test suite. GoogleTest calls <span class="tt">TearDownTestSuite()</span> after running the last test in the test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md712"></a>
HasFatalFailure {#Test::HasFatalFailure}</h4>
<p><span class="tt">static bool Test::HasFatalFailure()</span></p>
<p>Returns true if and only if the current test has a fatal failure.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md713"></a>
HasNonfatalFailure {#Test::HasNonfatalFailure}</h4>
<p><span class="tt">static bool Test::HasNonfatalFailure()</span></p>
<p>Returns true if and only if the current test has a nonfatal failure.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md714"></a>
HasFailure {#Test::HasFailure}</h4>
<p><span class="tt">static bool Test::HasFailure()</span></p>
<p>Returns true if and only if the current test has any failure, either fatal or nonfatal.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md715"></a>
IsSkipped {#Test::IsSkipped}</h4>
<p><span class="tt">static bool Test::IsSkipped()</span></p>
<p>Returns true if and only if the current test was skipped.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md716"></a>
RecordProperty {#Test::RecordProperty}</h4>
<p><span class="tt">static void Test::RecordProperty(const std::string&amp; key, const std::string&amp;
value)</span> \ <span class="tt">static void Test::RecordProperty(const std::string&amp; key, int value)</span></p>
<p>Logs a property for the current test, test suite, or entire invocation of the test program. Only the last value for a given key is logged.</p>
<p>The key must be a valid XML attribute name, and cannot conflict with the ones already used by GoogleTest (<span class="tt">name</span>, <span class="tt">file</span>, <span class="tt">line</span>, <span class="tt">status</span>, <span class="tt">time</span>, <span class="tt">classname</span>, <span class="tt">type_param</span>, and <span class="tt">value_param</span>).</p>
<p><span class="tt">RecordProperty</span> is <span class="tt">public static</span> so it can be called from utility functions that are not members of the test fixture.</p>
<p>Calls to <span class="tt">RecordProperty</span> made during the lifespan of the test (from the moment its constructor starts to the moment its destructor finishes) are output in XML as attributes of the <span class="tt">&lt;testcase&gt;</span> element. Properties recorded from a fixture's <span class="tt">SetUpTestSuite</span> or <span class="tt">TearDownTestSuite</span> methods are logged as attributes of the corresponding <span class="tt">&lt;testsuite&gt;</span> element. Calls to <span class="tt">RecordProperty</span> made in the global context (before or after invocation of <span class="tt">RUN_ALL_TESTS</span> or from the <span class="tt">SetUp</span>/<span class="tt">TearDown</span> methods of registered <span class="tt"><a class="el" href="class_environment.html">Environment</a></span> objects) are output as attributes of the <span class="tt">&lt;testsuites&gt;</span> element.</p>
<h3 class="doxsection"><a class="anchor" id="Test-protected"></a>
Protected Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md717"></a>
SetUp {#Test::SetUp}</h4>
<p><span class="tt">virtual void Test::SetUp()</span></p>
<p>Override this to perform test fixture setup. GoogleTest calls <span class="tt">SetUp()</span> before running each individual test.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md718"></a>
TearDown {#Test::TearDown}</h4>
<p><span class="tt">virtual void Test::TearDown()</span></p>
<p>Override this to perform test fixture teardown. GoogleTest calls <span class="tt">TearDown()</span> after running each individual test.</p>
<h2 class="doxsection"><a class="anchor" id="TestWithParam"></a>
TestWithParam</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_test_with_param.html">testing::TestWithParam</a>&lt;T&gt;</span></p>
<p>A convenience class which inherits from both <a class="el" href="#Test">`Test`</a> and <a class="el" href="#WithParamInterface">`WithParamInterface&lt;T&gt;`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="TestSuite"></a>
TestSuite</h2>
<p>Represents a test suite. <span class="tt">TestSuite</span> is not copyable.</p>
<h3 class="doxsection"><a class="anchor" id="TestSuite-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md719"></a>
name {#TestSuite::name}</h4>
<p><span class="tt">const char* TestSuite::name() const</span></p>
<p>Gets the name of the test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md720"></a>
type_param {#TestSuite::type_param}</h4>
<p><span class="tt">const char* TestSuite::type_param() const</span></p>
<p>Returns the name of the parameter type, or <span class="tt">NULL</span> if this is not a typed or type-parameterized test suite. See <a href="../advanced.md#typed-tests">Typed Tests</a> and <a href="../advanced.md#type-parameterized-tests">Type-Parameterized Tests</a>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md721"></a>
should_run {#TestSuite::should_run}</h4>
<p><span class="tt">bool TestSuite::should_run() const</span></p>
<p>Returns true if any test in this test suite should run.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md722"></a>
successful_test_count {#TestSuite::successful_test_count}</h4>
<p><span class="tt">int TestSuite::successful_test_count() const</span></p>
<p>Gets the number of successful tests in this test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md723"></a>
skipped_test_count {#TestSuite::skipped_test_count}</h4>
<p><span class="tt">int TestSuite::skipped_test_count() const</span></p>
<p>Gets the number of skipped tests in this test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md724"></a>
failed_test_count {#TestSuite::failed_test_count}</h4>
<p><span class="tt">int TestSuite::failed_test_count() const</span></p>
<p>Gets the number of failed tests in this test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md725"></a>
reportable_disabled_test_count {#TestSuite::reportable_disabled_test_count}</h4>
<p><span class="tt">int TestSuite::reportable_disabled_test_count() const</span></p>
<p>Gets the number of disabled tests that will be reported in the XML report.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md726"></a>
disabled_test_count {#TestSuite::disabled_test_count}</h4>
<p><span class="tt">int TestSuite::disabled_test_count() const</span></p>
<p>Gets the number of disabled tests in this test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md727"></a>
reportable_test_count {#TestSuite::reportable_test_count}</h4>
<p><span class="tt">int TestSuite::reportable_test_count() const</span></p>
<p>Gets the number of tests to be printed in the XML report.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md728"></a>
test_to_run_count {#TestSuite::test_to_run_count}</h4>
<p><span class="tt">int TestSuite::test_to_run_count() const</span></p>
<p>Get the number of tests in this test suite that should run.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md729"></a>
total_test_count {#TestSuite::total_test_count}</h4>
<p><span class="tt">int TestSuite::total_test_count() const</span></p>
<p>Gets the number of all tests in this test suite.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md730"></a>
Passed {#TestSuite::Passed}</h4>
<p><span class="tt">bool TestSuite::Passed() const</span></p>
<p>Returns true if and only if the test suite passed.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md731"></a>
Failed {#TestSuite::Failed}</h4>
<p><span class="tt">bool TestSuite::Failed() const</span></p>
<p>Returns true if and only if the test suite failed.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md732"></a>
elapsed_time {#TestSuite::elapsed_time}</h4>
<p><span class="tt">TimeInMillis TestSuite::elapsed_time() const</span></p>
<p>Returns the elapsed time, in milliseconds.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md733"></a>
start_timestamp {#TestSuite::start_timestamp}</h4>
<p><span class="tt">TimeInMillis TestSuite::start_timestamp() const</span></p>
<p>Gets the time of the test suite start, in ms from the start of the UNIX epoch.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md734"></a>
GetTestInfo {#TestSuite::GetTestInfo}</h4>
<p><span class="tt">const TestInfo* TestSuite::GetTestInfo(int i) const</span></p>
<p>Returns the <a class="el" href="#TestInfo">`TestInfo`</a> for the <span class="tt">i</span>-th test among all the tests. <span class="tt">i</span> can range from 0 to <span class="tt">total_test_count() - 1</span>. If <span class="tt">i</span> is not in that range, returns <span class="tt">NULL</span>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md735"></a>
ad_hoc_test_result {#TestSuite::ad_hoc_test_result}</h4>
<p><span class="tt">const <a class="el" href="class_test_result.html">TestResult</a>&amp; TestSuite::ad_hoc_test_result() const</span></p>
<p>Returns the <a class="el" href="#TestResult">`TestResult`</a> that holds test properties recorded during execution of <span class="tt">SetUpTestSuite</span> and <span class="tt">TearDownTestSuite</span>.</p>
<h2 class="doxsection"><a class="anchor" id="TestInfo"></a>
TestInfo</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_test_info.html">testing::TestInfo</a></span></p>
<p>Stores information about a test.</p>
<h3 class="doxsection"><a class="anchor" id="TestInfo-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md736"></a>
test_suite_name {#TestInfo::test_suite_name}</h4>
<p><span class="tt">const char* TestInfo::test_suite_name() const</span></p>
<p>Returns the test suite name.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md737"></a>
name {#TestInfo::name}</h4>
<p><span class="tt">const char* TestInfo::name() const</span></p>
<p>Returns the test name.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md738"></a>
type_param {#TestInfo::type_param}</h4>
<p><span class="tt">const char* TestInfo::type_param() const</span></p>
<p>Returns the name of the parameter type, or <span class="tt">NULL</span> if this is not a typed or type-parameterized test. See <a href="../advanced.md#typed-tests">Typed Tests</a> and <a href="../advanced.md#type-parameterized-tests">Type-Parameterized Tests</a>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md739"></a>
value_param {#TestInfo::value_param}</h4>
<p><span class="tt">const char* TestInfo::value_param() const</span></p>
<p>Returns the text representation of the value parameter, or <span class="tt">NULL</span> if this is not a value-parameterized test. See <a href="../advanced.md#value-parameterized-tests">Value-Parameterized Tests</a>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md740"></a>
file {#TestInfo::file}</h4>
<p><span class="tt">const char* TestInfo::file() const</span></p>
<p>Returns the file name where this test is defined.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md741"></a>
line {#TestInfo::line}</h4>
<p><span class="tt">int TestInfo::line() const</span></p>
<p>Returns the line where this test is defined.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md742"></a>
is_in_another_shard {#TestInfo::is_in_another_shard}</h4>
<p><span class="tt">bool TestInfo::is_in_another_shard() const</span></p>
<p>Returns true if this test should not be run because it's in another shard.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md743"></a>
should_run {#TestInfo::should_run}</h4>
<p><span class="tt">bool TestInfo::should_run() const</span></p>
<p>Returns true if this test should run, that is if the test is not disabled (or it is disabled but the <span class="tt">also_run_disabled_tests</span> flag has been specified) and its full name matches the user-specified filter.</p>
<p>GoogleTest allows the user to filter the tests by their full names. Only the tests that match the filter will run. See <a href="../advanced.md#running-a-subset-of-the-tests">Running a Subset of the Tests</a> for more information.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md744"></a>
is_reportable {#TestInfo::is_reportable}</h4>
<p><span class="tt">bool TestInfo::is_reportable() const</span></p>
<p>Returns true if and only if this test will appear in the XML report.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md745"></a>
result {#TestInfo::result}</h4>
<p><span class="tt">const TestResult* TestInfo::result() const</span></p>
<p>Returns the result of the test. See <a class="el" href="#TestResult">`TestResult`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="TestParamInfo"></a>
TestParamInfo</h2>
<p><span class="tt"><a class="el" href="structtesting_1_1_test_param_info.html">testing::TestParamInfo</a>&lt;T&gt;</span></p>
<p>Describes a parameter to a value-parameterized test. The type <span class="tt">T</span> is the type of the parameter.</p>
<p>Contains the fields <span class="tt">param</span> and <span class="tt">index</span> which hold the value of the parameter and its integer index respectively.</p>
<h2 class="doxsection"><a class="anchor" id="UnitTest"></a>
UnitTest</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_unit_test.html">testing::UnitTest</a></span></p>
<p>This class contains information about the test program.</p>
<p><span class="tt"><a class="el" href="class_unit_test.html">UnitTest</a></span> is a singleton class. The only instance is created when <span class="tt">UnitTest::GetInstance()</span> is first called. This instance is never deleted.</p>
<p><span class="tt"><a class="el" href="class_unit_test.html">UnitTest</a></span> is not copyable.</p>
<h3 class="doxsection"><a class="anchor" id="UnitTest-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md746"></a>
GetInstance {#UnitTest::GetInstance}</h4>
<p><span class="tt">static UnitTest* UnitTest::GetInstance()</span></p>
<p>Gets the singleton <span class="tt"><a class="el" href="class_unit_test.html">UnitTest</a></span> object. The first time this method is called, a <span class="tt"><a class="el" href="class_unit_test.html">UnitTest</a></span> object is constructed and returned. Consecutive calls will return the same object.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md747"></a>
original_working_dir {#UnitTest::original_working_dir}</h4>
<p><span class="tt">const char* UnitTest::original_working_dir() const</span></p>
<p>Returns the working directory when the first <a class="el" href="#TEST">`TEST()`</a> or <a class="el" href="#TEST_F">`TEST_F()`</a> was executed. The <span class="tt"><a class="el" href="class_unit_test.html">UnitTest</a></span> object owns the string.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md748"></a>
current_test_suite {#UnitTest::current_test_suite}</h4>
<p><span class="tt">const TestSuite* UnitTest::current_test_suite() const</span></p>
<p>Returns the <a class="el" href="#TestSuite">`TestSuite`</a> object for the test that's currently running, or <span class="tt">NULL</span> if no test is running.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md749"></a>
current_test_info {#UnitTest::current_test_info}</h4>
<p><span class="tt">const TestInfo* UnitTest::current_test_info() const</span></p>
<p>Returns the <a class="el" href="#TestInfo">`TestInfo`</a> object for the test that's currently running, or <span class="tt">NULL</span> if no test is running.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md750"></a>
random_seed {#UnitTest::random_seed}</h4>
<p><span class="tt">int UnitTest::random_seed() const</span></p>
<p>Returns the random seed used at the start of the current test run.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md751"></a>
successful_test_suite_count {#UnitTest::successful_test_suite_count}</h4>
<p><span class="tt">int UnitTest::successful_test_suite_count() const</span></p>
<p>Gets the number of successful test suites.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md752"></a>
failed_test_suite_count {#UnitTest::failed_test_suite_count}</h4>
<p><span class="tt">int UnitTest::failed_test_suite_count() const</span></p>
<p>Gets the number of failed test suites.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md753"></a>
total_test_suite_count {#UnitTest::total_test_suite_count}</h4>
<p><span class="tt">int UnitTest::total_test_suite_count() const</span></p>
<p>Gets the number of all test suites.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md754"></a>
test_suite_to_run_count {#UnitTest::test_suite_to_run_count}</h4>
<p><span class="tt">int UnitTest::test_suite_to_run_count() const</span></p>
<p>Gets the number of all test suites that contain at least one test that should run.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md755"></a>
successful_test_count {#UnitTest::successful_test_count}</h4>
<p><span class="tt">int UnitTest::successful_test_count() const</span></p>
<p>Gets the number of successful tests.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md756"></a>
skipped_test_count {#UnitTest::skipped_test_count}</h4>
<p><span class="tt">int UnitTest::skipped_test_count() const</span></p>
<p>Gets the number of skipped tests.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md757"></a>
failed_test_count {#UnitTest::failed_test_count}</h4>
<p><span class="tt">int UnitTest::failed_test_count() const</span></p>
<p>Gets the number of failed tests.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md758"></a>
reportable_disabled_test_count {#UnitTest::reportable_disabled_test_count}</h4>
<p><span class="tt">int UnitTest::reportable_disabled_test_count() const</span></p>
<p>Gets the number of disabled tests that will be reported in the XML report.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md759"></a>
disabled_test_count {#UnitTest::disabled_test_count}</h4>
<p><span class="tt">int UnitTest::disabled_test_count() const</span></p>
<p>Gets the number of disabled tests.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md760"></a>
reportable_test_count {#UnitTest::reportable_test_count}</h4>
<p><span class="tt">int UnitTest::reportable_test_count() const</span></p>
<p>Gets the number of tests to be printed in the XML report.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md761"></a>
total_test_count {#UnitTest::total_test_count}</h4>
<p><span class="tt">int UnitTest::total_test_count() const</span></p>
<p>Gets the number of all tests.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md762"></a>
test_to_run_count {#UnitTest::test_to_run_count}</h4>
<p><span class="tt">int UnitTest::test_to_run_count() const</span></p>
<p>Gets the number of tests that should run.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md763"></a>
start_timestamp {#UnitTest::start_timestamp}</h4>
<p><span class="tt">TimeInMillis UnitTest::start_timestamp() const</span></p>
<p>Gets the time of the test program start, in ms from the start of the UNIX epoch.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md764"></a>
elapsed_time {#UnitTest::elapsed_time}</h4>
<p><span class="tt">TimeInMillis UnitTest::elapsed_time() const</span></p>
<p>Gets the elapsed time, in milliseconds.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md765"></a>
Passed {#UnitTest::Passed}</h4>
<p><span class="tt">bool UnitTest::Passed() const</span></p>
<p>Returns true if and only if the unit test passed (i.e. all test suites passed).</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md766"></a>
Failed {#UnitTest::Failed}</h4>
<p><span class="tt">bool UnitTest::Failed() const</span></p>
<p>Returns true if and only if the unit test failed (i.e. some test suite failed or something outside of all tests failed).</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md767"></a>
GetTestSuite {#UnitTest::GetTestSuite}</h4>
<p><span class="tt">const TestSuite* UnitTest::GetTestSuite(int i) const</span></p>
<p>Gets the <a class="el" href="#TestSuite">`TestSuite`</a> object for the <span class="tt">i</span>-th test suite among all the test suites. <span class="tt">i</span> can range from 0 to <span class="tt">total_test_suite_count() - 1</span>. If <span class="tt">i</span> is not in that range, returns <span class="tt">NULL</span>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md768"></a>
ad_hoc_test_result {#UnitTest::ad_hoc_test_result}</h4>
<p><span class="tt">const <a class="el" href="class_test_result.html">TestResult</a>&amp; UnitTest::ad_hoc_test_result() const</span></p>
<p>Returns the <a class="el" href="#TestResult">`TestResult`</a> containing information on test failures and properties logged outside of individual test suites.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md769"></a>
listeners {#UnitTest::listeners}</h4>
<p><span class="tt"><a class="el" href="class_test_event_listeners.html">TestEventListeners</a>&amp; UnitTest::listeners()</span></p>
<p>Returns the list of event listeners that can be used to track events inside GoogleTest. See <a class="el" href="#TestEventListeners">`TestEventListeners`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="TestEventListener"></a>
TestEventListener</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_test_event_listener.html">testing::TestEventListener</a></span></p>
<p>The interface for tracing execution of tests. The methods below are listed in the order the corresponding events are fired.</p>
<h3 class="doxsection"><a class="anchor" id="TestEventListener-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md770"></a>
OnTestProgramStart {#TestEventListener::OnTestProgramStart}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestProgramStart(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp; unit_test)</span></p>
<p>Fired before any test activity starts.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md771"></a>
OnTestIterationStart {#TestEventListener::OnTestIterationStart}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestIterationStart(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp; unit_test,
int iteration)</span></p>
<p>Fired before each iteration of tests starts. There may be more than one iteration if <span class="tt">GTEST_FLAG(repeat)</span> is set. <span class="tt">iteration</span> is the iteration index, starting from 0.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md772"></a>
OnEnvironmentsSetUpStart {#TestEventListener::OnEnvironmentsSetUpStart}</h4>
<p><span class="tt">virtual void TestEventListener::OnEnvironmentsSetUpStart(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp;
unit_test)</span></p>
<p>Fired before environment set-up for each iteration of tests starts.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md773"></a>
OnEnvironmentsSetUpEnd {#TestEventListener::OnEnvironmentsSetUpEnd}</h4>
<p><span class="tt">virtual void TestEventListener::OnEnvironmentsSetUpEnd(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp;
unit_test)</span></p>
<p>Fired after environment set-up for each iteration of tests ends.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md774"></a>
OnTestSuiteStart {#TestEventListener::OnTestSuiteStart}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestSuiteStart(const TestSuite&amp; test_suite)</span></p>
<p>Fired before the test suite starts.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md775"></a>
OnTestStart {#TestEventListener::OnTestStart}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestStart(const <a class="el" href="class_test_info.html">TestInfo</a>&amp; test_info)</span></p>
<p>Fired before the test starts.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md776"></a>
OnTestPartResult {#TestEventListener::OnTestPartResult}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestPartResult(const TestPartResult&amp;
test_part_result)</span></p>
<p>Fired after a failed assertion or a <span class="tt">SUCCEED()</span> invocation. If you want to throw an exception from this function to skip to the next test, it must be an <a class="el" href="#AssertionException">`AssertionException`</a> or inherited from it.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md777"></a>
OnTestEnd {#TestEventListener::OnTestEnd}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestEnd(const <a class="el" href="class_test_info.html">TestInfo</a>&amp; test_info)</span></p>
<p>Fired after the test ends.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md778"></a>
OnTestSuiteEnd {#TestEventListener::OnTestSuiteEnd}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestSuiteEnd(const TestSuite&amp; test_suite)</span></p>
<p>Fired after the test suite ends.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md779"></a>
OnEnvironmentsTearDownStart {#TestEventListener::OnEnvironmentsTearDownStart}</h4>
<p><span class="tt">virtual void TestEventListener::OnEnvironmentsTearDownStart(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp;
unit_test)</span></p>
<p>Fired before environment tear-down for each iteration of tests starts.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md780"></a>
OnEnvironmentsTearDownEnd {#TestEventListener::OnEnvironmentsTearDownEnd}</h4>
<p><span class="tt">virtual void TestEventListener::OnEnvironmentsTearDownEnd(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp;
unit_test)</span></p>
<p>Fired after environment tear-down for each iteration of tests ends.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md781"></a>
OnTestIterationEnd {#TestEventListener::OnTestIterationEnd}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestIterationEnd(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp; unit_test,
int iteration)</span></p>
<p>Fired after each iteration of tests finishes.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md782"></a>
OnTestProgramEnd {#TestEventListener::OnTestProgramEnd}</h4>
<p><span class="tt">virtual void TestEventListener::OnTestProgramEnd(const <a class="el" href="class_unit_test.html">UnitTest</a>&amp; unit_test)</span></p>
<p>Fired after all test activities have ended.</p>
<h2 class="doxsection"><a class="anchor" id="TestEventListeners"></a>
TestEventListeners</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_test_event_listeners.html">testing::TestEventListeners</a></span></p>
<p>Lets users add listeners to track events in GoogleTest.</p>
<h3 class="doxsection"><a class="anchor" id="TestEventListeners-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md783"></a>
Append {#TestEventListeners::Append}</h4>
<p><span class="tt">void TestEventListeners::Append(TestEventListener* listener)</span></p>
<p>Appends an event listener to the end of the list. GoogleTest assumes ownership of the listener (i.e. it will delete the listener when the test program finishes).</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md784"></a>
Release {#TestEventListeners::Release}</h4>
<p><span class="tt">TestEventListener* TestEventListeners::Release(TestEventListener* listener)</span></p>
<p>Removes the given event listener from the list and returns it. It then becomes the caller's responsibility to delete the listener. Returns <span class="tt">NULL</span> if the listener is not found in the list.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md785"></a>
default_result_printer {#TestEventListeners::default_result_printer}</h4>
<p><span class="tt">TestEventListener* TestEventListeners::default_result_printer() const</span></p>
<p>Returns the standard listener responsible for the default console output. Can be removed from the listeners list to shut down default console output. Note that removing this object from the listener list with `Release()` transfers its ownership to the caller and makes this function return <span class="tt">NULL</span> the next time.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md786"></a>
default_xml_generator {#TestEventListeners::default_xml_generator}</h4>
<p><span class="tt">TestEventListener* TestEventListeners::default_xml_generator() const</span></p>
<p>Returns the standard listener responsible for the default XML output controlled by the <span class="tt">--gtest_output=xml</span> flag. Can be removed from the listeners list by users who want to shut down the default XML output controlled by this flag and substitute it with custom one. Note that removing this object from the listener list with `Release()` transfers its ownership to the caller and makes this function return <span class="tt">NULL</span> the next time.</p>
<h2 class="doxsection"><a class="anchor" id="TestPartResult"></a>
TestPartResult</h2>
<p><span class="tt">testing::TestPartResult</span></p>
<p>A copyable object representing the result of a test part (i.e. an assertion or an explicit <span class="tt">FAIL()</span>, <span class="tt">ADD_FAILURE()</span>, or <span class="tt">SUCCESS()</span>).</p>
<h3 class="doxsection"><a class="anchor" id="TestPartResult-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md787"></a>
type {#TestPartResult::type}</h4>
<p><span class="tt">Type TestPartResult::type() const</span></p>
<p>Gets the outcome of the test part.</p>
<p>The return type <span class="tt">Type</span> is an enum defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> Type {</div>
<div class="line">  kSuccess,          <span class="comment">// Succeeded.</span></div>
<div class="line">  kNonFatalFailure,  <span class="comment">// Failed but the test can continue.</span></div>
<div class="line">  kFatalFailure,     <span class="comment">// Failed and the test should be terminated.</span></div>
<div class="line">  kSkip              <span class="comment">// Skipped.</span></div>
<div class="line">};</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md788"></a>
file_name {#TestPartResult::file_name}</h4>
<p><span class="tt">const char* TestPartResult::file_name() const</span></p>
<p>Gets the name of the source file where the test part took place, or <span class="tt">NULL</span> if it's unknown.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md789"></a>
line_number {#TestPartResult::line_number}</h4>
<p><span class="tt">int TestPartResult::line_number() const</span></p>
<p>Gets the line in the source file where the test part took place, or <span class="tt">-1</span> if it's unknown.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md790"></a>
summary {#TestPartResult::summary}</h4>
<p><span class="tt">const char* TestPartResult::summary() const</span></p>
<p>Gets the summary of the failure message.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md791"></a>
message {#TestPartResult::message}</h4>
<p><span class="tt">const char* TestPartResult::message() const</span></p>
<p>Gets the message associated with the test part.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md792"></a>
skipped {#TestPartResult::skipped}</h4>
<p><span class="tt">bool TestPartResult::skipped() const</span></p>
<p>Returns true if and only if the test part was skipped.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md793"></a>
passed {#TestPartResult::passed}</h4>
<p><span class="tt">bool TestPartResult::passed() const</span></p>
<p>Returns true if and only if the test part passed.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md794"></a>
nonfatally_failed {#TestPartResult::nonfatally_failed}</h4>
<p><span class="tt">bool TestPartResult::nonfatally_failed() const</span></p>
<p>Returns true if and only if the test part non-fatally failed.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md795"></a>
fatally_failed {#TestPartResult::fatally_failed}</h4>
<p><span class="tt">bool TestPartResult::fatally_failed() const</span></p>
<p>Returns true if and only if the test part fatally failed.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md796"></a>
failed {#TestPartResult::failed}</h4>
<p><span class="tt">bool TestPartResult::failed() const</span></p>
<p>Returns true if and only if the test part failed.</p>
<h2 class="doxsection"><a class="anchor" id="TestProperty"></a>
TestProperty</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_test_property.html">testing::TestProperty</a></span></p>
<p>A copyable object representing a user-specified test property which can be output as a key/value string pair.</p>
<h3 class="doxsection"><a class="anchor" id="TestProperty-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="key"></a>
key</h4>
<p><span class="tt">const char* key() const</span></p>
<p>Gets the user-supplied key.</p>
<h4 class="doxsection"><a class="anchor" id="value"></a>
value</h4>
<p><span class="tt">const char* value() const</span></p>
<p>Gets the user-supplied value.</p>
<h4 class="doxsection"><a class="anchor" id="SetValue"></a>
SetValue</h4>
<p><span class="tt">void SetValue(const std::string&amp; new_value)</span></p>
<p>Sets a new value, overriding the previous one.</p>
<h2 class="doxsection"><a class="anchor" id="TestResult"></a>
TestResult</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_test_result.html">testing::TestResult</a></span></p>
<p>Contains information about the result of a single test.</p>
<p><span class="tt"><a class="el" href="class_test_result.html">TestResult</a></span> is not copyable.</p>
<h3 class="doxsection"><a class="anchor" id="TestResult-public"></a>
Public Methods</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md797"></a>
total_part_count {#TestResult::total_part_count}</h4>
<p><span class="tt">int TestResult::total_part_count() const</span></p>
<p>Gets the number of all test parts. This is the sum of the number of successful test parts and the number of failed test parts.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md798"></a>
test_property_count {#TestResult::test_property_count}</h4>
<p><span class="tt">int TestResult::test_property_count() const</span></p>
<p>Returns the number of test properties.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md799"></a>
Passed {#TestResult::Passed}</h4>
<p><span class="tt">bool TestResult::Passed() const</span></p>
<p>Returns true if and only if the test passed (i.e. no test part failed).</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md800"></a>
Skipped {#TestResult::Skipped}</h4>
<p><span class="tt">bool TestResult::Skipped() const</span></p>
<p>Returns true if and only if the test was skipped.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md801"></a>
Failed {#TestResult::Failed}</h4>
<p><span class="tt">bool TestResult::Failed() const</span></p>
<p>Returns true if and only if the test failed.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md802"></a>
HasFatalFailure {#TestResult::HasFatalFailure}</h4>
<p><span class="tt">bool TestResult::HasFatalFailure() const</span></p>
<p>Returns true if and only if the test fatally failed.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md803"></a>
HasNonfatalFailure {#TestResult::HasNonfatalFailure}</h4>
<p><span class="tt">bool TestResult::HasNonfatalFailure() const</span></p>
<p>Returns true if and only if the test has a non-fatal failure.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md804"></a>
elapsed_time {#TestResult::elapsed_time}</h4>
<p><span class="tt">TimeInMillis TestResult::elapsed_time() const</span></p>
<p>Returns the elapsed time, in milliseconds.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md805"></a>
start_timestamp {#TestResult::start_timestamp}</h4>
<p><span class="tt">TimeInMillis TestResult::start_timestamp() const</span></p>
<p>Gets the time of the test case start, in ms from the start of the UNIX epoch.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md806"></a>
GetTestPartResult {#TestResult::GetTestPartResult}</h4>
<p><span class="tt">const TestPartResult&amp; TestResult::GetTestPartResult(int i) const</span></p>
<p>Returns the <a class="el" href="#TestPartResult">`TestPartResult`</a> for the <span class="tt">i</span>-th test part result among all the results. <span class="tt">i</span> can range from 0 to <span class="tt">total_part_count() - 1</span>. If <span class="tt">i</span> is not in that range, aborts the program.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md807"></a>
GetTestProperty {#TestResult::GetTestProperty}</h4>
<p><span class="tt">const <a class="el" href="class_test_property.html">TestProperty</a>&amp; TestResult::GetTestProperty(int i) const</span></p>
<p>Returns the <a class="el" href="#TestProperty">`TestProperty`</a> object for the <span class="tt">i</span>-th test property. <span class="tt">i</span> can range from 0 to <span class="tt">test_property_count() - 1</span>. If <span class="tt">i</span> is not in that range, aborts the program.</p>
<h2 class="doxsection"><a class="anchor" id="TimeInMillis"></a>
TimeInMillis</h2>
<p><span class="tt">testing::TimeInMillis</span></p>
<p>An integer type representing time in milliseconds.</p>
<h2 class="doxsection"><a class="anchor" id="Types"></a>
Types</h2>
<p><span class="tt">testing::Types&lt;T...&gt;</span></p>
<p>Represents a list of types for use in typed tests and type-parameterized tests.</p>
<p>The template argument <span class="tt">T...</span> can be any number of types, for example:</p>
<div class="fragment"><div class="line">testing::Types&lt;char, int, unsigned int&gt;</div>
</div><!-- fragment --><p>See <a href="../advanced.md#typed-tests">Typed Tests</a> and <a href="../advanced.md#type-parameterized-tests">Type-Parameterized Tests</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="WithParamInterface"></a>
WithParamInterface</h2>
<p><span class="tt"><a class="el" href="classtesting_1_1_with_param_interface.html">testing::WithParamInterface</a>&lt;T&gt;</span></p>
<p>The pure interface class that all value-parameterized tests inherit from.</p>
<p>A value-parameterized test fixture class must inherit from both <a class="el" href="#Test">`Test`</a> and <span class="tt">WithParamInterface</span>. In most cases that just means inheriting from <a class="el" href="#TestWithParam">`TestWithParam`</a>, but more complicated test hierarchies may need to inherit from <span class="tt">Test</span> and <span class="tt">WithParamInterface</span> at different levels.</p>
<p>This interface defines the type alias <span class="tt">ParamType</span> for the parameter type <span class="tt">T</span> and has support for accessing the test parameter value via the <span class="tt">GetParam()</span> method:</p>
<div class="fragment"><div class="line">static const ParamType&amp; GetParam()</div>
</div><!-- fragment --><p>For more information, see <a href="../advanced.md#value-parameterized-tests">Value-Parameterized Tests</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md808"></a>
Functions</h1>
<p>GoogleTest defines the following functions to help with writing and running tests.</p>
<h2 class="doxsection"><a class="anchor" id="InitGoogleTest"></a>
InitGoogleTest</h2>
<p><span class="tt">void testing::InitGoogleTest(int* argc, char** argv)</span> \ <span class="tt">void testing::InitGoogleTest(int* argc, wchar_t** argv)</span> \ <span class="tt">void testing::InitGoogleTest()</span></p>
<p>Initializes GoogleTest. This must be called before calling <a class="el" href="#RUN_ALL_TESTS">`RUN_ALL_TESTS()`</a>. In particular, it parses the command line for the flags that GoogleTest recognizes. Whenever a GoogleTest flag is seen, it is removed from <span class="tt">argv</span>, and <span class="tt">*argc</span> is decremented. Keep in mind that <span class="tt">argv</span> must terminate with a <span class="tt">NULL</span> pointer (i.e. <span class="tt">argv[argc]</span> is <span class="tt">NULL</span>), which is already the case with the default <span class="tt">argv</span> passed to <span class="tt">main</span>.</p>
<p>No value is returned. Instead, the GoogleTest flag variables are updated.</p>
<p>The <span class="tt">InitGoogleTest(int* argc, wchar_t** argv)</span> overload can be used in Windows programs compiled in <span class="tt">UNICODE</span> mode.</p>
<p>The argument-less <span class="tt">InitGoogleTest()</span> overload can be used on Arduino/embedded platforms where there is no <span class="tt">argc</span>/<span class="tt">argv</span>.</p>
<h2 class="doxsection"><a class="anchor" id="AddGlobalTestEnvironment"></a>
AddGlobalTestEnvironment</h2>
<p><span class="tt">Environment* testing::AddGlobalTestEnvironment(Environment* env)</span></p>
<p>Adds a test environment to the test program. Must be called before <a class="el" href="#RUN_ALL_TESTS">`RUN_ALL_TESTS()`</a> is called. See <a href="../advanced.md#global-set-up-and-tear-down">Global Set-Up and Tear-Down</a> for more information.</p>
<p>See also <a class="el" href="#Environment">`Environment`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="RegisterTest"></a>
RegisterTest</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Factory&gt;</div>
<div class="line"><a class="code hl_class" href="class_test_info.html">TestInfo</a>* testing::RegisterTest(<span class="keyword">const</span> <span class="keywordtype">char</span>* test_suite_name, <span class="keyword">const</span> <span class="keywordtype">char</span>* test_name,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* type_param, <span class="keyword">const</span> <span class="keywordtype">char</span>* value_param,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">int</span> line, Factory factory)</div>
<div class="ttc" id="aclass_test_info_html"><div class="ttname"><a href="class_test_info.html">TestInfo</a></div><div class="ttdef"><b>Определения</b> gtest.h:533</div></div>
</div><!-- fragment --><p>Dynamically registers a test with the framework.</p>
<p>The <span class="tt">factory</span> argument is a factory callable (move-constructible) object or function pointer that creates a new instance of the <span class="tt">Test</span> object. It handles ownership to the caller. The signature of the callable is <span class="tt">Fixture*()</span>, where <span class="tt"><a class="el" href="class_fixture.html">Fixture</a></span> is the test fixture class for the test. All tests registered with the same <span class="tt">test_suite_name</span> must return the same fixture type. This is checked at runtime.</p>
<p>The framework will infer the fixture class from the factory and will call the <span class="tt">SetUpTestSuite</span> and <span class="tt">TearDownTestSuite</span> methods for it.</p>
<p>Must be called before <a class="el" href="#RUN_ALL_TESTS">`RUN_ALL_TESTS()`</a> is invoked, otherwise behavior is undefined.</p>
<p>See <a href="../advanced.md#registering-tests-programmatically">Registering tests programmatically</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="RUN_ALL_TESTS"></a>
RUN_ALL_TESTS</h2>
<p><span class="tt">int RUN_ALL_TESTS()</span></p>
<p>Use this function in <span class="tt">main()</span> to run all tests. It returns <span class="tt">0</span> if all tests are successful, or <span class="tt">1</span> otherwise.</p>
<p><span class="tt">RUN_ALL_TESTS()</span> should be invoked after the command line has been parsed by <a class="el" href="#InitGoogleTest">`InitGoogleTest()`</a>.</p>
<p>This function was formerly a macro; thus, it is in the global namespace and has an all-caps name.</p>
<h2 class="doxsection"><a class="anchor" id="AssertionSuccess"></a>
AssertionSuccess</h2>
<p><span class="tt">AssertionResult testing::AssertionSuccess()</span></p>
<p>Creates a successful assertion result. See <a class="el" href="#AssertionResult">`AssertionResult`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="AssertionFailure"></a>
AssertionFailure</h2>
<p><span class="tt">AssertionResult testing::AssertionFailure()</span></p>
<p>Creates a failed assertion result. Use the <span class="tt">&lt;&lt;</span> operator to store a failure message:</p>
<div class="fragment"><div class="line">testing::AssertionFailure() &lt;&lt; <span class="stringliteral">&quot;My failure message&quot;</span>;</div>
</div><!-- fragment --><p>See <a class="el" href="#AssertionResult">`AssertionResult`</a>.</p>
<h2 class="doxsection"><a class="anchor" id="StaticAssertTypeEq"></a>
StaticAssertTypeEq</h2>
<p><span class="tt">testing::StaticAssertTypeEq&lt;T1, T2&gt;()</span></p>
<p>Compile-time assertion for type equality. Compiles if and only if <span class="tt">T1</span> and <span class="tt">T2</span> are the same type. The value it returns is irrelevant.</p>
<p>See <a href="../advanced.md#type-assertions">Type Assertions</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="PrintToString"></a>
PrintToString</h2>
<p><span class="tt">std::string testing::PrintToString(x)</span></p>
<p>Prints any value <span class="tt">x</span> using GoogleTest's value printer.</p>
<p>See <a href="../advanced.md#teaching-googletest-how-to-print-your-values">Teaching GoogleTest How to Print Your Values</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="PrintToStringParamName"></a>
PrintToStringParamName</h2>
<p><span class="tt">std::string <a class="el" href="structtesting_1_1_print_to_string_param_name.html">testing::PrintToStringParamName</a>(TestParamInfo&lt;T&gt;&amp; info)</span></p>
<p>A built-in parameterized test name generator which returns the result of <a class="el" href="#PrintToString">`PrintToString`</a> called on <span class="tt">info.param</span>. Does not work when the test parameter is a <span class="tt">std::string</span> or C string. See <a href="../advanced.md#specifying-names-for-value-parameterized-test-parameters">Specifying Names for Value-Parameterized Test Parameters</a> for more information.</p>
<p>See also <a class="el" href="#TestParamInfo">`TestParamInfo`</a> and <a class="el" href="#INSTANTIATE_TEST_SUITE_P">`INSTANTIATE_TEST_SUITE_P`</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Globalizer</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Искать" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Навигация</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="_base_interval_8h_source.html">Исходный файл globalizer/method/include/BaseInterval.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="_base_parameters_8h.html">Файл globalizer/parameters/include/BaseParameters.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="class_solver.html">Класс Solver</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, TODO.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/html/md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2testing.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>