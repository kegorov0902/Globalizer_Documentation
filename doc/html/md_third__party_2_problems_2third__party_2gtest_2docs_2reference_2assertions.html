<!DOCTYPE html>

<html lang="ru" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Globalizer: Assertions Reference &#8212; документация Globalizer 141025</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=799f848e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cd1d70c9"></script>
    <link rel="index" title="Алфавитный указатель" href="../genindex.html" />
    <link rel="search" title="Поиск" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="assertions-reference">
<h1>Assertions Reference<a class="headerlink" href="#assertions-reference" title="Ссылка на этот заголовок">¶</a></h1>
<div class="doxygen-content docutils container">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Globalizer: Assertions Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Globalizer<span id="projectnumber">&#160;1.1</span>
   </div>
   <div id="projectbrief">Exascale Minimizer - параллельная программная система для решения задач глобальной оптимизации</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Поиск',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Assertions Reference </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md681"></a></p>
<p>This page lists the assertion macros provided by GoogleTest for verifying code behavior. To use them, add <span class="tt">#include &lt;gtest/gtest.h&gt;</span>.</p>
<p>The majority of the macros listed below come as a pair with an <span class="tt">EXPECT_</span> variant and an <span class="tt">ASSERT_</span> variant. Upon failure, <span class="tt">EXPECT_</span> macros generate nonfatal failures and allow the current function to continue running, while <span class="tt">ASSERT_</span> macros generate fatal failures and abort the current function.</p>
<p>All assertion macros support streaming a custom failure message into them with the <span class="tt">&lt;&lt;</span> operator, for example:</p>
<div class="fragment"><div class="line">EXPECT_TRUE(my_condition) &lt;&lt; <span class="stringliteral">&quot;My condition is not true&quot;</span>;</div>
</div><!-- fragment --><p>Anything that can be streamed to an <span class="tt">ostream</span> can be streamed to an assertion macro—in particular, C strings and string objects. If a wide string (<span class="tt">wchar_t*</span>, <span class="tt">TCHAR*</span> in <span class="tt">UNICODE</span> mode on Windows, or <span class="tt">std::wstring</span>) is streamed to an assertion, it will be translated to UTF-8 when printed.</p>
<h1 class="doxsection"><a class="anchor" id="success-failure"></a>
Explicit Success and Failure</h1>
<p>The assertions in this section generate a success or failure directly instead of testing a value or expression. These are useful when control flow, rather than a Boolean expression, determines the test's success or failure, as shown by the following example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span>(expression) {</div>
<div class="line">  <span class="keywordflow">case</span> 1:</div>
<div class="line">    ... some checks ...</div>
<div class="line">  <span class="keywordflow">case</span> 2:</div>
<div class="line">    ... some other checks ...</div>
<div class="line">  <span class="keywordflow">default</span>:</div>
<div class="line">    FAIL() &lt;&lt; <span class="stringliteral">&quot;We shouldn&#39;t get here.&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="SUCCEED"></a>
SUCCEED</h2>
<p><span class="tt">SUCCEED()</span></p>
<p>Generates a success. This <em>does not</em> make the overall test succeed. A test is considered successful only if none of its assertions fail during its execution.</p>
<p>The <span class="tt">SUCCEED</span> assertion is purely documentary and currently doesn't generate any user-visible output. However, we may add <span class="tt">SUCCEED</span> messages to GoogleTest output in the future.</p>
<h2 class="doxsection"><a class="anchor" id="FAIL"></a>
FAIL</h2>
<p><span class="tt">FAIL()</span></p>
<p>Generates a fatal failure, which returns from the current function.</p>
<p>Can only be used in functions that return <span class="tt">void</span>. See <a href="../advanced.md#assertion-placement">Assertion Placement</a> for more information.</p>
<h2 class="doxsection"><a class="anchor" id="ADD_FAILURE"></a>
ADD_FAILURE</h2>
<p><span class="tt">ADD_FAILURE()</span></p>
<p>Generates a nonfatal failure, which allows the current function to continue running.</p>
<h2 class="doxsection"><a class="anchor" id="ADD_FAILURE_AT"></a>
ADD_FAILURE_AT</h2>
<p><span class="tt">ADD_FAILURE_AT(</span>*<span class="tt">file_path</span>*<span class="tt">,</span>*<span class="tt">line_number</span>*<span class="tt">)</span></p>
<p>Generates a nonfatal failure at the file and line number specified.</p>
<h1 class="doxsection"><a class="anchor" id="generalized"></a>
Generalized Assertion</h1>
<p>The following assertion allows <a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2matchers.html">matchers</a> to be used to verify values.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_THAT"></a>
EXPECT_THAT</h2>
<p><span class="tt">EXPECT_THAT(</span>*<span class="tt">value</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_THAT(</span>*<span class="tt">value</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">value</span></em> matches the <a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2matchers.html">matcher</a> <em><span class="tt">matcher</span></em>.</p>
<p>For example, the following code verifies that the string <span class="tt">value1</span> starts with <span class="tt">"Hello"</span>, <span class="tt">value2</span> matches a regular expression, and <span class="tt">value3</span> is between 5 and 10:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gmock/gmock.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>::testing::AllOf;</div>
<div class="line"><span class="keyword">using </span>::testing::Gt;</div>
<div class="line"><span class="keyword">using </span>::testing::Lt;</div>
<div class="line"><span class="keyword">using </span>::testing::MatchesRegex;</div>
<div class="line"><span class="keyword">using </span>::testing::StartsWith;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">EXPECT_THAT(value1, StartsWith(<span class="stringliteral">&quot;Hello&quot;</span>));</div>
<div class="line">EXPECT_THAT(value2, MatchesRegex(<span class="stringliteral">&quot;Line \\d+&quot;</span>));</div>
<div class="line">ASSERT_THAT(value3, AllOf(Gt(5), Lt(10)));</div>
</div><!-- fragment --><p>Matchers enable assertions of this form to read like English and generate informative failure messages. For example, if the above assertion on <span class="tt">value1</span> fails, the resulting message will be similar to the following:</p>
<div class="fragment"><div class="line">Value of: value1</div>
<div class="line">  Actual: &quot;Hi, world!&quot;</div>
<div class="line">Expected: starts with &quot;Hello&quot;</div>
</div><!-- fragment --><p>GoogleTest provides a built-in library of matchers—see the <a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2matchers.html">Matchers Reference</a>. It is also possible to write your own matchers—see <a href="../gmock_cook_book.md#NewMatchers">Writing New Matchers Quickly</a>. The use of matchers makes <span class="tt">EXPECT_THAT</span> a powerful, extensible assertion.</p>
<p><em>The idea for this assertion was borrowed from Joe Walnes' Hamcrest project, which adds <span class="tt">assertThat()</span> to JUnit.</em></p>
<h1 class="doxsection"><a class="anchor" id="boolean"></a>
Boolean Conditions</h1>
<p>The following assertions test Boolean conditions.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_TRUE"></a>
EXPECT_TRUE</h2>
<p><span class="tt">EXPECT_TRUE(</span>*<span class="tt">condition</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_TRUE(</span>*<span class="tt">condition</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">condition</span></em> is true.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_FALSE"></a>
EXPECT_FALSE</h2>
<p><span class="tt">EXPECT_FALSE(</span>*<span class="tt">condition</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_FALSE(</span>*<span class="tt">condition</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">condition</span></em> is false.</p>
<h1 class="doxsection"><a class="anchor" id="binary-comparison"></a>
Binary Comparison</h1>
<p>The following assertions compare two values. The value arguments must be comparable by the assertion's comparison operator, otherwise a compiler error will result.</p>
<p>If an argument supports the <span class="tt">&lt;&lt;</span> operator, it will be called to print the argument when the assertion fails. Otherwise, GoogleTest will attempt to print them in the best way it can—see <a href="../advanced.md#teaching-googletest-how-to-print-your-values">Teaching GoogleTest How to Print Your Values</a>.</p>
<p>Arguments are always evaluated exactly once, so it's OK for the arguments to have side effects. However, the argument evaluation order is undefined and programs should not depend on any particular argument evaluation order.</p>
<p>These assertions work with both narrow and wide string objects (<span class="tt">string</span> and <span class="tt">wstring</span>).</p>
<p>See also the <a class="el" href="#floating-point">Floating-Point Comparison</a> assertions to compare floating-point numbers and avoid problems caused by rounding.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_EQ"></a>
EXPECT_EQ</h2>
<p><span class="tt">EXPECT_EQ(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_EQ(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">val1</span></em><span class="tt">==</span>*<span class="tt">val2</span>*.</p>
<p>Does pointer equality on pointers. If used on two C strings, it tests if they are in the same memory location, not if they have the same value. Use <a class="el" href="#EXPECT_STREQ">`EXPECT_STREQ`</a> to compare C strings (e.g. <span class="tt">const char*</span>) by value.</p>
<p>When comparing a pointer to <span class="tt">NULL</span>, use <span class="tt">EXPECT_EQ(</span>*<span class="tt">ptr</span>*<span class="tt">, nullptr)</span> instead of <span class="tt">EXPECT_EQ(</span>*<span class="tt">ptr</span>*<span class="tt">, NULL)</span>.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_NE"></a>
EXPECT_NE</h2>
<p><span class="tt">EXPECT_NE(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_NE(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">val1</span></em><span class="tt">!=</span>*<span class="tt">val2</span>*.</p>
<p>Does pointer equality on pointers. If used on two C strings, it tests if they are in different memory locations, not if they have different values. Use <a class="el" href="#EXPECT_STRNE">`EXPECT_STRNE`</a> to compare C strings (e.g. <span class="tt">const char*</span>) by value.</p>
<p>When comparing a pointer to <span class="tt">NULL</span>, use <span class="tt">EXPECT_NE(</span>*<span class="tt">ptr</span>*<span class="tt">, nullptr)</span> instead of <span class="tt">EXPECT_NE(</span>*<span class="tt">ptr</span>*<span class="tt">, NULL)</span>.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_LT"></a>
EXPECT_LT</h2>
<p><span class="tt">EXPECT_LT(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_LT(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">val1</span></em><span class="tt">&lt;</span>*<span class="tt">val2</span>*.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_LE"></a>
EXPECT_LE</h2>
<p><span class="tt">EXPECT_LE(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_LE(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">val1</span></em><span class="tt">&lt;=</span>*<span class="tt">val2</span>*.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_GT"></a>
EXPECT_GT</h2>
<p><span class="tt">EXPECT_GT(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_GT(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">val1</span></em><span class="tt">&gt;</span>*<span class="tt">val2</span>*.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_GE"></a>
EXPECT_GE</h2>
<p><span class="tt">EXPECT_GE(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_GE(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">val1</span></em><span class="tt">&gt;=</span>*<span class="tt">val2</span>*.</p>
<h1 class="doxsection"><a class="anchor" id="c-strings"></a>
String Comparison</h1>
<p>The following assertions compare two <b>C strings</b>. To compare two <span class="tt">string</span> objects, use <a class="el" href="#EXPECT_EQ">`EXPECT_EQ`</a> or <a class="el" href="#EXPECT_NE">`EXPECT_NE`</a> instead.</p>
<p>These assertions also accept wide C strings (<span class="tt">wchar_t*</span>). If a comparison of two wide strings fails, their values will be printed as UTF-8 narrow strings.</p>
<p>To compare a C string with <span class="tt">NULL</span>, use <span class="tt">EXPECT_EQ(</span>*<span class="tt">c_string</span>*<span class="tt">, nullptr)</span> or <span class="tt">EXPECT_NE(</span>*<span class="tt">c_string</span>*<span class="tt">, nullptr)</span>.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_STREQ"></a>
EXPECT_STREQ</h2>
<p><span class="tt">EXPECT_STREQ(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_STREQ(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span></p>
<p>Verifies that the two C strings <em><span class="tt">str1</span></em> and <em><span class="tt">str2</span></em> have the same contents.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_STRNE"></a>
EXPECT_STRNE</h2>
<p><span class="tt">EXPECT_STRNE(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_STRNE(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span></p>
<p>Verifies that the two C strings <em><span class="tt">str1</span></em> and <em><span class="tt">str2</span></em> have different contents.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_STRCASEEQ"></a>
EXPECT_STRCASEEQ</h2>
<p><span class="tt">EXPECT_STRCASEEQ(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_STRCASEEQ(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span></p>
<p>Verifies that the two C strings <em><span class="tt">str1</span></em> and <em><span class="tt">str2</span></em> have the same contents, ignoring case.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_STRCASENE"></a>
EXPECT_STRCASENE</h2>
<p><span class="tt">EXPECT_STRCASENE(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_STRCASENE(</span>*<span class="tt">str1</span>*<span class="tt">,</span>*<span class="tt">str2</span>*<span class="tt">)</span></p>
<p>Verifies that the two C strings <em><span class="tt">str1</span></em> and <em><span class="tt">str2</span></em> have different contents, ignoring case.</p>
<h1 class="doxsection"><a class="anchor" id="floating-point"></a>
Floating-Point Comparison</h1>
<p>The following assertions compare two floating-point values.</p>
<p>Due to rounding errors, it is very unlikely that two floating-point values will match exactly, so <span class="tt">EXPECT_EQ</span> is not suitable. In general, for floating-point comparison to make sense, the user needs to carefully choose the error bound.</p>
<p>GoogleTest also provides assertions that use a default error bound based on Units in the Last Place (ULPs). To learn more about ULPs, see the article <a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">Comparing Floating Point Numbers</a>.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_FLOAT_EQ"></a>
EXPECT_FLOAT_EQ</h2>
<p><span class="tt">EXPECT_FLOAT_EQ(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_FLOAT_EQ(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that the two <span class="tt">float</span> values <em><span class="tt">val1</span></em> and <em><span class="tt">val2</span></em> are approximately equal, to within 4 ULPs from each other. Infinity and the largest finite float value are considered to be one ULP apart.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_DOUBLE_EQ"></a>
EXPECT_DOUBLE_EQ</h2>
<p><span class="tt">EXPECT_DOUBLE_EQ(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_DOUBLE_EQ(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span></p>
<p>Verifies that the two <span class="tt">double</span> values <em><span class="tt">val1</span></em> and <em><span class="tt">val2</span></em> are approximately equal, to within 4 ULPs from each other. Infinity and the largest finite double value are considered to be one ULP apart.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_NEAR"></a>
EXPECT_NEAR</h2>
<p><span class="tt">EXPECT_NEAR(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">abs_error</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_NEAR(</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">abs_error</span>*<span class="tt">)</span></p>
<p>Verifies that the difference between <em><span class="tt">val1</span></em> and <em><span class="tt">val2</span></em> does not exceed the absolute error bound <em><span class="tt">abs_error</span></em>.</p>
<p>If <em><span class="tt">val</span></em> and <em><span class="tt">val2</span></em> are both infinity of the same sign, the difference is considered to be 0. Otherwise, if either value is infinity, the difference is considered to be infinity. All non-NaN values (including infinity) are considered to not exceed an <em><span class="tt">abs_error</span></em> of infinity.</p>
<h1 class="doxsection"><a class="anchor" id="exceptions"></a>
Exception Assertions</h1>
<p>The following assertions verify that a piece of code throws, or does not throw, an exception. Usage requires exceptions to be enabled in the build environment.</p>
<p>Note that the piece of code under test can be a compound statement, for example:</p>
<div class="fragment"><div class="line">EXPECT_NO_THROW({</div>
<div class="line">  <span class="keywordtype">int</span> n = 5;</div>
<div class="line">  DoSomething(&amp;n);</div>
<div class="line">});</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="EXPECT_THROW"></a>
EXPECT_THROW</h2>
<p><span class="tt">EXPECT_THROW(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">exception_type</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_THROW(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">exception_type</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">statement</span></em> throws an exception of type <em><span class="tt">exception_type</span></em>.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_ANY_THROW"></a>
EXPECT_ANY_THROW</h2>
<p><span class="tt">EXPECT_ANY_THROW(</span>*<span class="tt">statement</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_ANY_THROW(</span>*<span class="tt">statement</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">statement</span></em> throws an exception of any type.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_NO_THROW"></a>
EXPECT_NO_THROW</h2>
<p><span class="tt">EXPECT_NO_THROW(</span>*<span class="tt">statement</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_NO_THROW(</span>*<span class="tt">statement</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">statement</span></em> does not throw any exception.</p>
<h1 class="doxsection"><a class="anchor" id="predicates"></a>
Predicate Assertions</h1>
<p>The following assertions enable more complex predicates to be verified while printing a more clear failure message than if <span class="tt">EXPECT_TRUE</span> were used alone.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_PRED"></a>
EXPECT_PRED*</h2>
<p><span class="tt">EXPECT_PRED1(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED2(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED3(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED4(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED5(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">,</span>*<span class="tt">val5</span>*<span class="tt">)</span></p>
<p><span class="tt">ASSERT_PRED1(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED2(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED3(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED4(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED5(</span>*<span class="tt">pred</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">,</span>*<span class="tt">val5</span>*<span class="tt">)</span></p>
<p>Verifies that the predicate <em><span class="tt">pred</span></em> returns <span class="tt">true</span> when passed the given values as arguments.</p>
<p>The parameter <em><span class="tt">pred</span></em> is a function or functor that accepts as many arguments as the corresponding macro accepts values. If <em><span class="tt">pred</span></em> returns <span class="tt">true</span> for the given arguments, the assertion succeeds, otherwise the assertion fails.</p>
<p>When the assertion fails, it prints the value of each argument. Arguments are always evaluated exactly once.</p>
<p>As an example, see the following code:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns true if m and n have no common divisors except 1.</span></div>
<div class="line"><span class="keywordtype">bool</span> MutuallyPrime(<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n) { ... }</div>
<div class="line">...</div>
<div class="line">const <span class="keywordtype">int</span> a = 3;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> b = 4;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> c = 10;</div>
<div class="line">...</div>
<div class="line">EXPECT_PRED2(MutuallyPrime, a, b);  <span class="comment">// Succeeds</span></div>
<div class="line">EXPECT_PRED2(MutuallyPrime, b, c);  <span class="comment">// Fails</span></div>
</div><!-- fragment --><p>In the above example, the first assertion succeeds, and the second fails with the following message:</p>
<div class="fragment"><div class="line">MutuallyPrime(b, c) is false, where</div>
<div class="line">b is 4</div>
<div class="line">c is 10</div>
</div><!-- fragment --><p>Note that if the given predicate is an overloaded function or a function template, the assertion macro might not be able to determine which version to use, and it might be necessary to explicitly specify the type of the function. For example, for a Boolean function <span class="tt">IsPositive()</span> overloaded to take either a single <span class="tt">int</span> or <span class="tt">double</span> argument, it would be necessary to write one of the following:</p>
<div class="fragment"><div class="line">EXPECT_PRED1(<span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span> (*)(<span class="keywordtype">int</span>)<span class="keyword">&gt;</span>(IsPositive), 5);</div>
<div class="line">EXPECT_PRED1(<span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span> (*)(<span class="keywordtype">double</span>)<span class="keyword">&gt;</span>(IsPositive), 3.14);</div>
</div><!-- fragment --><p>Writing simply <span class="tt">EXPECT_PRED1(IsPositive, 5);</span> would result in a compiler error. Similarly, to use a template function, specify the template arguments:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">bool</span> IsNegative(T x) {</div>
<div class="line">  <span class="keywordflow">return</span> x &lt; 0;</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">EXPECT_PRED1(IsNegative&lt;int&gt;, -5);  <span class="comment">// Must specify type for IsNegative</span></div>
</div><!-- fragment --><p>If a template has multiple parameters, wrap the predicate in parentheses so the macro arguments are parsed correctly:</p>
<div class="fragment"><div class="line">ASSERT_PRED2((MyPredicate&lt;int, int&gt;), 5, 0);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="EXPECT_PRED_FORMAT"></a>
EXPECT_PRED_FORMAT*</h2>
<p><span class="tt">EXPECT_PRED_FORMAT1(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED_FORMAT2(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED_FORMAT3(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED_FORMAT4(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">)</span> \ <span class="tt">EXPECT_PRED_FORMAT5(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">,</span>*<span class="tt">val5</span>*<span class="tt">)</span></p>
<p><span class="tt">ASSERT_PRED_FORMAT1(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED_FORMAT2(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED_FORMAT3(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED_FORMAT4(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_PRED_FORMAT5(</span>*<span class="tt">pred_formatter</span>*<span class="tt">,</span>*<span class="tt">val1</span>*<span class="tt">,</span>*<span class="tt">val2</span>*<span class="tt">,</span>*<span class="tt">val3</span>*<span class="tt">,</span>*<span class="tt">val4</span>*<span class="tt">,</span>*<span class="tt">val5</span>*<span class="tt">)</span></p>
<p>Verifies that the predicate <em><span class="tt">pred_formatter</span></em> succeeds when passed the given values as arguments.</p>
<p>The parameter <em><span class="tt">pred_formatter</span></em> is a <em>predicate-formatter</em>, which is a function or functor with the signature:</p>
<div class="fragment"><div class="line">testing::AssertionResult PredicateFormatter(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1,</div>
<div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,</div>
<div class="line">                                            ...</div>
<div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">char</span>* exprn,</div>
<div class="line">                                            T1 val1,</div>
<div class="line">                                            T2 val2,</div>
<div class="line">                                            ...</div>
<div class="line">                                            Tn valn);</div>
</div><!-- fragment --><p>where <em><span class="tt">val1</span></em>, <em><span class="tt">val2</span></em>, ..., <em><span class="tt">valn</span></em> are the values of the predicate arguments, and <em><span class="tt">expr1</span></em>, <em><span class="tt">expr2</span></em>, ..., <em><span class="tt">exprn</span></em> are the corresponding expressions as they appear in the source code. The types <span class="tt">T1</span>, <span class="tt">T2</span>, ..., <span class="tt">Tn</span> can be either value types or reference types; if an argument has type <span class="tt">T</span>, it can be declared as either <span class="tt">T</span> or <span class="tt">const T&amp;</span>, whichever is appropriate. For more about the return type <span class="tt">testing::AssertionResult</span>, see <a href="../advanced.md#using-a-function-that-returns-an-assertionresult">Using a Function That Returns an AssertionResult</a>.</p>
<p>As an example, see the following code:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the smallest prime common divisor of m and n,</span></div>
<div class="line"><span class="comment">// or 1 when m and n are mutually prime.</span></div>
<div class="line"><span class="keywordtype">int</span> SmallestPrimeCommonDivisor(<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns true if m and n have no common divisors except 1.</span></div>
<div class="line"><span class="keywordtype">bool</span> MutuallyPrime(<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A predicate-formatter for asserting that two integers are mutually prime.</span></div>
<div class="line">testing::AssertionResult AssertMutuallyPrime(<span class="keyword">const</span> <span class="keywordtype">char</span>* m_expr,</div>
<div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">char</span>* n_expr,</div>
<div class="line">                                             <span class="keywordtype">int</span> m,</div>
<div class="line">                                             <span class="keywordtype">int</span> n) {</div>
<div class="line">  <span class="keywordflow">if</span> (MutuallyPrime(m, n)) <span class="keywordflow">return</span> testing::AssertionSuccess();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> testing::AssertionFailure() &lt;&lt; m_expr &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; n_expr</div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;) are not mutually prime, &quot;</span></div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;as they have a common divisor &quot;</span> &lt;&lt; SmallestPrimeCommonDivisor(m, n);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">const <span class="keywordtype">int</span> a = 3;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> b = 4;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> c = 10;</div>
<div class="line">...</div>
<div class="line">EXPECT_PRED_FORMAT2(AssertMutuallyPrime, a, b);  <span class="comment">// Succeeds</span></div>
<div class="line">EXPECT_PRED_FORMAT2(AssertMutuallyPrime, b, c);  <span class="comment">// Fails</span></div>
</div><!-- fragment --><p>In the above example, the final assertion fails and the predicate-formatter produces the following failure message:</p>
<div class="fragment"><div class="line">b and c (4 and 10) are not mutually prime, as they have a common divisor 2</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="HRESULT"></a>
Windows HRESULT Assertions</h1>
<p>The following assertions test for <span class="tt">HRESULT</span> success or failure. For example:</p>
<div class="fragment"><div class="line">CComPtr&lt;IShellDispatch2&gt; shell;</div>
<div class="line">ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L<span class="stringliteral">&quot;Shell.Application&quot;</span>));</div>
<div class="line">CComVariant empty;</div>
<div class="line">ASSERT_HRESULT_SUCCEEDED(shell-&gt;ShellExecute(CComBSTR(url), empty, empty, empty, empty));</div>
</div><!-- fragment --><p>The generated output contains the human-readable error message associated with the returned <span class="tt">HRESULT</span> code.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_HRESULT_SUCCEEDED"></a>
EXPECT_HRESULT_SUCCEEDED</h2>
<p><span class="tt">EXPECT_HRESULT_SUCCEEDED(</span>*<span class="tt">expression</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_HRESULT_SUCCEEDED(</span>*<span class="tt">expression</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">expression</span></em> is a success <span class="tt">HRESULT</span>.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_HRESULT_FAILED"></a>
EXPECT_HRESULT_FAILED</h2>
<p><span class="tt">EXPECT_HRESULT_FAILED(</span>*<span class="tt">expression</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_HRESULT_FAILED(</span>*<span class="tt">expression</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">expression</span></em> is a failure <span class="tt">HRESULT</span>.</p>
<h1 class="doxsection"><a class="anchor" id="death"></a>
Death Assertions</h1>
<p>The following assertions verify that a piece of code causes the process to terminate. For context, see <a href="../advanced.md#death-tests">Death Tests</a>.</p>
<p>These assertions spawn a new process and execute the code under test in that process. How that happens depends on the platform and the variable <span class="tt">::testing::GTEST_FLAG(death_test_style)</span>, which is initialized from the command-line flag <span class="tt">--gtest_death_test_style</span>.</p>
<ul>
<li>On POSIX systems, <span class="tt">fork()</span> (or <span class="tt">clone()</span> on Linux) is used to spawn the child, after which:<ul>
<li>If the variable's value is <span class="tt">"fast"</span>, the death test statement is immediately executed.</li>
<li>If the variable's value is <span class="tt">"threadsafe"</span>, the child process re-executes the unit test binary just as it was originally invoked, but with some extra flags to cause just the single death test under consideration to be run.</li>
</ul>
</li>
<li>On Windows, the child is spawned using the <span class="tt">CreateProcess()</span> API, and re-executes the binary to cause just the single death test under consideration to be run - much like the <span class="tt">"threadsafe"</span> mode on POSIX.</li>
</ul>
<p>Other values for the variable are illegal and will cause the death test to fail. Currently, the flag's default value is <b><span class="tt">"fast"</span></b>.</p>
<p>If the death test statement runs to completion without dying, the child process will nonetheless terminate, and the assertion fails.</p>
<p>Note that the piece of code under test can be a compound statement, for example:</p>
<div class="fragment"><div class="line">EXPECT_DEATH({</div>
<div class="line">  <span class="keywordtype">int</span> n = 5;</div>
<div class="line">  DoSomething(&amp;n);</div>
<div class="line">}, <span class="stringliteral">&quot;Error on line .* of DoSomething()&quot;</span>);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="EXPECT_DEATH"></a>
EXPECT_DEATH</h2>
<p><span class="tt">EXPECT_DEATH(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_DEATH(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">statement</span></em> causes the process to terminate with a nonzero exit status and produces <span class="tt">stderr</span> output that matches <em><span class="tt">matcher</span></em>.</p>
<p>The parameter <em><span class="tt">matcher</span></em> is either a <a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2matchers.html">matcher</a> for a <span class="tt">const
std::string&amp;</span>, or a regular expression (see <a href="../advanced.md#regular-expression-syntax">Regular Expression Syntax</a>)—a bare string <em><span class="tt">s</span></em> (with no matcher) is treated as <a href="matchers.md#string-matchers"><span class="tt">ContainsRegex(s)</span></a>, <b>not</b> <a href="matchers.md#generic-comparison"><span class="tt">Eq(s)</span></a>.</p>
<p>For example, the following code verifies that calling <span class="tt">DoSomething(42)</span> causes the process to die with an error message that contains the text <span class="tt">My error</span>:</p>
<div class="fragment"><div class="line">EXPECT_DEATH(DoSomething(42), <span class="stringliteral">&quot;My error&quot;</span>);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="EXPECT_DEATH_IF_SUPPORTED"></a>
EXPECT_DEATH_IF_SUPPORTED</h2>
<p><span class="tt">EXPECT_DEATH_IF_SUPPORTED(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_DEATH_IF_SUPPORTED(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span></p>
<p>If death tests are supported, behaves the same as <a class="el" href="#EXPECT_DEATH">`EXPECT_DEATH`</a>. Otherwise, verifies nothing.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_DEBUG_DEATH"></a>
EXPECT_DEBUG_DEATH</h2>
<p><span class="tt">EXPECT_DEBUG_DEATH(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_DEBUG_DEATH(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span></p>
<p>In debug mode, behaves the same as <a class="el" href="#EXPECT_DEATH">`EXPECT_DEATH`</a>. When not in debug mode (i.e. <span class="tt">NDEBUG</span> is defined), just executes <em><span class="tt">statement</span></em>.</p>
<h2 class="doxsection"><a class="anchor" id="EXPECT_EXIT"></a>
EXPECT_EXIT</h2>
<p><span class="tt">EXPECT_EXIT(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">predicate</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span> \ <span class="tt">ASSERT_EXIT(</span>*<span class="tt">statement</span>*<span class="tt">,</span>*<span class="tt">predicate</span>*<span class="tt">,</span>*<span class="tt">matcher</span>*<span class="tt">)</span></p>
<p>Verifies that <em><span class="tt">statement</span></em> causes the process to terminate with an exit status that satisfies <em><span class="tt">predicate</span></em>, and produces <span class="tt">stderr</span> output that matches <em><span class="tt">matcher</span></em>.</p>
<p>The parameter <em><span class="tt">predicate</span></em> is a function or functor that accepts an <span class="tt">int</span> exit status and returns a <span class="tt">bool</span>. GoogleTest provides two predicates to handle common cases:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns true if the program exited normally with the given exit status code.</span></div>
<div class="line">::testing::ExitedWithCode(exit_code);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns true if the program was killed by the given signal.</span></div>
<div class="line"><span class="comment">// Not available on Windows.</span></div>
<div class="line">::testing::KilledBySignal(signal_number);</div>
</div><!-- fragment --><p>The parameter <em><span class="tt">matcher</span></em> is either a <a class="el" href="md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2matchers.html">matcher</a> for a <span class="tt">const
std::string&amp;</span>, or a regular expression (see <a href="../advanced.md#regular-expression-syntax">Regular Expression Syntax</a>)—a bare string <em><span class="tt">s</span></em> (with no matcher) is treated as <a href="matchers.md#string-matchers"><span class="tt">ContainsRegex(s)</span></a>, <b>not</b> <a href="matchers.md#generic-comparison"><span class="tt">Eq(s)</span></a>.</p>
<p>For example, the following code verifies that calling <span class="tt">NormalExit()</span> causes the process to print a message containing the text <span class="tt">Success</span> to <span class="tt">stderr</span> and exit with exit status code 0:</p>
<div class="fragment"><div class="line">EXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), <span class="stringliteral">&quot;Success&quot;</span>);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Globalizer</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Искать" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Навигация</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="_base_interval_8h_source.html">Исходный файл globalizer/method/include/BaseInterval.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="_base_parameters_8h.html">Файл globalizer/parameters/include/BaseParameters.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="class_solver.html">Класс Solver</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, TODO.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/html/md_third__party_2_problems_2third__party_2gtest_2docs_2reference_2assertions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>