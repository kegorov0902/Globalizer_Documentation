<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Globalizer: GoogleTest FAQ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Globalizer<span id="projectnumber">&#160;1.1</span>
   </div>
   <div id="projectbrief">Exascale Minimizer - параллельная программная система для решения задач глобальной оптимизации</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Поиск',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">GoogleTest FAQ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md87"></a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md88"></a>
Why should test suite names and test names not contain underscore?</h1>
<p>{: .callout .note} Note: GoogleTest reserves underscore (<span class="tt">_</span>) for special-purpose keywords, such as <a href="advanced.md#temporarily-disabling-tests">the <span class="tt">DISABLED_</span> prefix</a>, in addition to the following rationale.</p>
<p>Underscore (<span class="tt">_</span>) is special, as C++ reserves the following to be used by the compiler and the standard library:</p>
<ol type="1">
<li>any identifier that starts with an <span class="tt">_</span> followed by an upper-case letter, and</li>
<li>any identifier that contains two consecutive underscores (i.e. <span class="tt">__</span>) <em>anywhere</em> in its name.</li>
</ol>
<p>User code is <em>prohibited</em> from using such identifiers.</p>
<p>Now let's look at what this means for <span class="tt">TEST</span> and <span class="tt">TEST_F</span>.</p>
<p>Currently <span class="tt">TEST(TestSuiteName, TestName)</span> generates a class named <span class="tt">TestSuiteName_TestName_Test</span>. What happens if <span class="tt">TestSuiteName</span> or <span class="tt">TestName</span> contains <span class="tt">_</span>?</p>
<ol type="1">
<li>If <span class="tt">TestSuiteName</span> starts with an <span class="tt">_</span> followed by an upper-case letter (say, <span class="tt">_Foo</span>), we end up with <span class="tt">_Foo_TestName_Test</span>, which is reserved and thus invalid.</li>
<li>If <span class="tt">TestSuiteName</span> ends with an <span class="tt">_</span> (say, <span class="tt">Foo_</span>), we get <span class="tt">Foo__TestName_Test</span>, which is invalid.</li>
<li>If <span class="tt">TestName</span> starts with an <span class="tt">_</span> (say, <span class="tt">_Bar</span>), we get <span class="tt">TestSuiteName__Bar_Test</span>, which is invalid.</li>
<li>If <span class="tt">TestName</span> ends with an <span class="tt">_</span> (say, <span class="tt">Bar_</span>), we get <span class="tt">TestSuiteName_Bar__Test</span>, which is invalid.</li>
</ol>
<p>So clearly <span class="tt">TestSuiteName</span> and <span class="tt">TestName</span> cannot start or end with <span class="tt">_</span> (Actually, <span class="tt">TestSuiteName</span> can start with <span class="tt">_</span>—as long as the <span class="tt">_</span> isn't followed by an upper-case letter. But that's getting complicated. So for simplicity we just say that it cannot start with <span class="tt">_</span>.).</p>
<p>It may seem fine for <span class="tt">TestSuiteName</span> and <span class="tt">TestName</span> to contain <span class="tt">_</span> in the middle. However, consider this:</p>
<div class="fragment"><div class="line">TEST(Time, Flies_Like_An_Arrow) { ... }</div>
<div class="line">TEST(Time_Flies, Like_An_Arrow) { ... }</div>
</div><!-- fragment --><p>Now, the two <span class="tt">TEST</span>s will both generate the same class (<span class="tt">Time_Flies_Like_An_Arrow_Test</span>). That's not good.</p>
<p>So for simplicity, we just ask the users to avoid <span class="tt">_</span> in <span class="tt">TestSuiteName</span> and <span class="tt">TestName</span>. The rule is more constraining than necessary, but it's simple and easy to remember. It also gives GoogleTest some wiggle room in case its implementation needs to change in the future.</p>
<p>If you violate the rule, there may not be immediate consequences, but your test may (just may) break with a new compiler (or a new version of the compiler you are using) or with a new version of GoogleTest. Therefore it's best to follow the rule.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md89"></a>
Why does GoogleTest support <span class="tt">EXPECT_EQ(NULL, ptr)</span> and <span class="tt">ASSERT_EQ(NULL, ptr)</span> but not <span class="tt">EXPECT_NE(NULL, ptr)</span> and <span class="tt">ASSERT_NE(NULL, ptr)</span>?</h1>
<p>First of all, you can use <span class="tt">nullptr</span> with each of these macros, e.g. <span class="tt">EXPECT_EQ(ptr, nullptr)</span>, <span class="tt">EXPECT_NE(ptr, nullptr)</span>, <span class="tt">ASSERT_EQ(ptr, nullptr)</span>, <span class="tt">ASSERT_NE(ptr, nullptr)</span>. This is the preferred syntax in the style guide because <span class="tt">nullptr</span> does not have the type problems that <span class="tt">NULL</span> does.</p>
<p>Due to some peculiarity of C++, it requires some non-trivial template meta programming tricks to support using <span class="tt">NULL</span> as an argument of the <span class="tt">EXPECT_XX()</span> and <span class="tt">ASSERT_XX()</span> macros. Therefore we only do it where it's most needed (otherwise we make the implementation of GoogleTest harder to maintain and more error-prone than necessary).</p>
<p>Historically, the <span class="tt">EXPECT_EQ()</span> macro took the <em>expected</em> value as its first argument and the <em>actual</em> value as the second, though this argument order is now discouraged. It was reasonable that someone wanted to write <span class="tt">EXPECT_EQ(NULL, some_expression)</span>, and this indeed was requested several times. Therefore we implemented it.</p>
<p>The need for <span class="tt">EXPECT_NE(NULL, ptr)</span> wasn't nearly as strong. When the assertion fails, you already know that <span class="tt">ptr</span> must be <span class="tt">NULL</span>, so it doesn't add any information to print <span class="tt">ptr</span> in this case. That means <span class="tt">EXPECT_TRUE(ptr != NULL)</span> works just as well.</p>
<p>If we were to support <span class="tt">EXPECT_NE(NULL, ptr)</span>, for consistency we'd have to support <span class="tt">EXPECT_NE(ptr, NULL)</span> as well. This means using the template meta programming tricks twice in the implementation, making it even harder to understand and maintain. We believe the benefit doesn't justify the cost.</p>
<p>Finally, with the growth of the gMock matcher library, we are encouraging people to use the unified <span class="tt">EXPECT_THAT(value, matcher)</span> syntax more often in tests. One significant advantage of the matcher approach is that matchers can be easily combined to form new matchers, while the <span class="tt">EXPECT_NE</span>, etc, macros cannot be easily combined. Therefore we want to invest more in the matchers than in the <span class="tt">EXPECT_XX()</span> macros.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md90"></a>
I need to test that different implementations of an interface satisfy some common requirements. Should I use typed tests or value-parameterized tests?</h1>
<p>For testing various implementations of the same interface, either typed tests or value-parameterized tests can get it done. It's really up to you the user to decide which is more convenient for you, depending on your particular case. Some rough guidelines:</p>
<ul>
<li>Typed tests can be easier to write if instances of the different implementations can be created the same way, modulo the type. For example, if all these implementations have a public default constructor (such that you can write <span class="tt">new TypeParam</span>), or if their factory functions have the same form (e.g. <span class="tt">CreateInstance&lt;TypeParam&gt;()</span>).</li>
<li>Value-parameterized tests can be easier to write if you need different code patterns to create different implementations' instances, e.g. <span class="tt">new Foo</span> vs <span class="tt">new Bar(5)</span>. To accommodate for the differences, you can write factory function wrappers and pass these function pointers to the tests as their parameters.</li>
<li>When a typed test fails, the default output includes the name of the type, which can help you quickly identify which implementation is wrong. Value-parameterized tests only show the number of the failed iteration by default. You will need to define a function that returns the iteration name and pass it as the third parameter to INSTANTIATE_TEST_SUITE_P to have more useful output.</li>
<li>When using typed tests, you need to make sure you are testing against the interface type, not the concrete types (in other words, you want to make sure <span class="tt">implicit_cast&lt;MyInterface*&gt;(my_concrete_impl)</span> works, not just that <span class="tt">my_concrete_impl</span> works). It's less likely to make mistakes in this area when using value-parameterized tests.</li>
</ul>
<p>I hope I didn't confuse you more. :-) If you don't mind, I'd suggest you to give both approaches a try. Practice is a much better way to grasp the subtle differences between the two tools. Once you have some concrete experience, you can much more easily decide which one to use the next time.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md91"></a>
My death test modifies some state, but the change seems lost after the death test finishes. Why?</h1>
<p>Death tests (<span class="tt">EXPECT_DEATH</span>, etc.) are executed in a sub-process s.t. the expected crash won't kill the test program (i.e. the parent process). As a result, any in-memory side effects they incur are observable in their respective sub-processes, but not in the parent process. You can think of them as running in a parallel universe, more or less.</p>
<p>In particular, if you use mocking and the death test statement invokes some mock methods, the parent process will think the calls have never occurred. Therefore, you may want to move your <span class="tt">EXPECT_CALL</span> statements inside the <span class="tt">EXPECT_DEATH</span> macro.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md92"></a>
EXPECT_EQ(htonl(blah), blah_blah) generates weird compiler errors in opt mode. Is this a GoogleTest bug?</h1>
<p>Actually, the bug is in <span class="tt">htonl()</span>.</p>
<p>According to &lsquo;'man htonl&rsquo;<span class="tt">, </span>htonl()<span class="tt"> is a *function*, which means it's valid to
use </span>htonl<span class="tt"> as a function pointer. However, in opt mode </span>htonl()` is defined as a <em>macro</em>, which breaks this usage.</p>
<p>Worse, the macro definition of <span class="tt">htonl()</span> uses a <span class="tt">gcc</span> extension and is <em>not</em> standard C++. That hacky implementation has some ad hoc limitations. In particular, it prevents you from writing <span class="tt">Foo&lt;sizeof(htonl(x))&gt;()</span>, where <span class="tt">Foo</span> is a template that has an integral argument.</p>
<p>The implementation of <span class="tt">EXPECT_EQ(a, b)</span> uses <span class="tt">sizeof(... a ...)</span> inside a template argument, and thus doesn't compile in opt mode when <span class="tt">a</span> contains a call to <span class="tt">htonl()</span>. It is difficult to make <span class="tt">EXPECT_EQ</span> bypass the <span class="tt">htonl()</span> bug, as the solution must work with different compilers on various platforms.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md93"></a>
The compiler complains about "undefined references" to some static const member variables, but I did define them in the class body. What's wrong?</h1>
<p>If your class has a static data member:</p>
<div class="fragment"><div class="line"><span class="comment">// foo.h</span></div>
<div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kBar = 100;</div>
<div class="line">};</div>
</div><!-- fragment --><p>you also need to define it <em>outside</em> of the class body in <span class="tt">foo.cc</span>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> Foo::kBar;  <span class="comment">// No initializer here.</span></div>
</div><!-- fragment --><p>Otherwise your code is <b>invalid C++</b>, and may break in unexpected ways. In particular, using it in GoogleTest comparison assertions (<span class="tt">EXPECT_EQ</span>, etc.) will generate an "undefined reference" linker error. The fact that "it used to
work" doesn't mean it's valid. It just means that you were lucky. :-)</p>
<p>If the declaration of the static data member is <span class="tt">constexpr</span> then it is implicitly an <span class="tt">inline</span> definition, and a separate definition in <span class="tt">foo.cc</span> is not needed:</p>
<div class="fragment"><div class="line"><span class="comment">// foo.h</span></div>
<div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">int</span> kBar = 100;  <span class="comment">// Defines kBar, no need to do it in foo.cc.</span></div>
<div class="line">};</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
Can I derive a test fixture from another?</h1>
<p>Yes.</p>
<p>Each test fixture has a corresponding and same named test suite. This means only one test suite can use a particular fixture. Sometimes, however, multiple test cases may want to use the same or slightly different fixtures. For example, you may want to make sure that all of a GUI library's test suites don't leak important system resources like fonts and brushes.</p>
<p>In GoogleTest, you share a fixture among test suites by putting the shared logic in a base test fixture, then deriving from that base a separate fixture for each test suite that wants to use this common logic. You then use <span class="tt">TEST_F()</span> to write tests using each derived fixture.</p>
<p>Typically, your code looks like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Defines a base test fixture.</span></div>
<div class="line"><span class="keyword">class </span>BaseTest : <span class="keyword">public</span> <a class="code hl_class" href="classtesting_1_1_test.html">::testing::Test</a> {</div>
<div class="line"> <span class="keyword">protected</span>:</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Derives a fixture FooTest from BaseTest.</span></div>
<div class="line"><span class="keyword">class </span>FooTest : <span class="keyword">public</span> BaseTest {</div>
<div class="line"> <span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">void</span> SetUp()<span class="keyword"> override </span>{</div>
<div class="line">    BaseTest::SetUp();  <span class="comment">// Sets up the base fixture first.</span></div>
<div class="line">    ... additional set-up work ...</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> TearDown()<span class="keyword"> override </span>{</div>
<div class="line">    ... clean-up work <span class="keywordflow">for</span> FooTest ...</div>
<div class="line">    BaseTest::TearDown();  <span class="comment">// Remember to tear down the base fixture</span></div>
<div class="line">                           <span class="comment">// after cleaning up FooTest!</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  ... functions and variables <span class="keywordflow">for</span> FooTest ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Tests that use the fixture FooTest.</span></div>
<div class="line">TEST_F(FooTest, Bar) { ... }</div>
<div class="line">TEST_F(FooTest, Baz) { ... }</div>
<div class="line"> </div>
<div class="line">... additional fixtures derived from BaseTest ...</div>
<div class="ttc" id="aclasstesting_1_1_test_html"><div class="ttname"><a href="classtesting_1_1_test.html">testing::Test</a></div><div class="ttdef"><b>Определения</b> gtest.h:242</div></div>
</div><!-- fragment --><p>If necessary, you can continue to derive test fixtures from a derived fixture. GoogleTest has no limit on how deep the hierarchy can be.</p>
<p>For a complete example using derived test fixtures, see <a href="https://github.com/google/googletest/blob/main/googletest/samples/sample5_unittest.cc">sample5_unittest.cc</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md95"></a>
My compiler complains "void value not ignored as it ought to be." What does this mean?</h1>
<p>You're probably using an <span class="tt">ASSERT_*()</span> in a function that doesn't return <span class="tt">void</span>. <span class="tt">ASSERT_*()</span> can only be used in <span class="tt">void</span> functions, due to exceptions being disabled by our build system. Please see more details <a href="advanced.md#assertion-placement">here</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
My death test hangs (or seg-faults). How do I fix it?</h1>
<p>In GoogleTest, death tests are run in a child process and the way they work is delicate. To write death tests you really need to understand how they work—see the details at <a href="reference/assertions.md#death">Death Assertions</a> in the Assertions Reference.</p>
<p>In particular, death tests don't like having multiple threads in the parent process. So the first thing you can try is to eliminate creating threads outside of <span class="tt">EXPECT_DEATH()</span>. For example, you may want to use mocks or fake objects instead of real ones in your tests.</p>
<p>Sometimes this is impossible as some library you must use may be creating threads before <span class="tt">main()</span> is even reached. In this case, you can try to minimize the chance of conflicts by either moving as many activities as possible inside <span class="tt">EXPECT_DEATH()</span> (in the extreme case, you want to move everything inside), or leaving as few things as possible in it. Also, you can try to set the death test style to <span class="tt">"threadsafe"</span>, which is safer but slower, and see if it helps.</p>
<p>If you go with thread-safe death tests, remember that they rerun the test program from the beginning in the child process. Therefore make sure your program can run side-by-side with itself and is deterministic.</p>
<p>In the end, this boils down to good concurrent programming. You have to make sure that there are no race conditions or deadlocks in your program. No silver bullet - sorry!</p>
<h1 class="doxsection"><a class="anchor" id="CtorVsSetUp"></a>
Should I use the constructor/destructor of the test fixture or SetUp()/TearDown()?</h1>
<p>The first thing to remember is that GoogleTest does <b>not</b> reuse the same test fixture object across multiple tests. For each <span class="tt">TEST_F</span>, GoogleTest will create a <b>fresh</b> test fixture object, immediately call <span class="tt">SetUp()</span>, run the test body, call <span class="tt">TearDown()</span>, and then delete the test fixture object.</p>
<p>When you need to write per-test set-up and tear-down logic, you have the choice between using the test fixture constructor/destructor or <span class="tt">SetUp()</span>/<span class="tt">TearDown()</span>. The former is usually preferred, as it has the following benefits:</p>
<ul>
<li>By initializing a member variable in the constructor, we have the option to make it <span class="tt">const</span>, which helps prevent accidental changes to its value and makes the tests more obviously correct.</li>
<li>In case we need to subclass the test fixture class, the subclass' constructor is guaranteed to call the base class' constructor <em>first</em>, and the subclass' destructor is guaranteed to call the base class' destructor <em>afterward</em>. With <span class="tt">SetUp()/TearDown()</span>, a subclass may make the mistake of forgetting to call the base class' <span class="tt">SetUp()/TearDown()</span> or call them at the wrong time.</li>
</ul>
<p>You may still want to use <span class="tt">SetUp()/TearDown()</span> in the following cases:</p>
<ul>
<li>C++ does not allow virtual function calls in constructors and destructors. You can call a method declared as virtual, but it will not use dynamic dispatch. It will use the definition from the class the constructor of which is currently executing. This is because calling a virtual method before the derived class constructor has a chance to run is very dangerous - the virtual method might operate on uninitialized data. Therefore, if you need to call a method that will be overridden in a derived class, you have to use <span class="tt">SetUp()/TearDown()</span>.</li>
<li>In the body of a constructor (or destructor), it's not possible to use the <span class="tt">ASSERT_xx</span> macros. Therefore, if the set-up operation could cause a fatal test failure that should prevent the test from running, it's necessary to use <span class="tt">abort</span> and abort the whole test executable, or to use <span class="tt">SetUp()</span> instead of a constructor.</li>
<li>If the tear-down operation could throw an exception, you must use <span class="tt">TearDown()</span> as opposed to the destructor, as throwing in a destructor leads to undefined behavior and usually will kill your program right away. Note that many standard libraries (like STL) may throw when exceptions are enabled in the compiler. Therefore you should prefer <span class="tt">TearDown()</span> if you want to write portable tests that work with or without exceptions.</li>
<li>The GoogleTest team is considering making the assertion macros throw on platforms where exceptions are enabled (e.g. Windows, Mac OS, and Linux client-side), which will eliminate the need for the user to propagate failures from a subroutine to its caller. Therefore, you shouldn't use GoogleTest assertions in a destructor if your code could run on such a platform.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
The compiler complains "no matching function to call" when I use <span class="tt">ASSERT_PRED*</span>. How do I fix it?</h1>
<p>See details for <a href="reference/assertions.md#EXPECT_PRED"><span class="tt">EXPECT_PRED*</span></a> in the Assertions Reference.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
My compiler complains about "ignoring return value" when I call RUN_ALL_TESTS(). Why?</h1>
<p>Some people had been ignoring the return value of <span class="tt">RUN_ALL_TESTS()</span>. That is, instead of</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> RUN_ALL_TESTS();</div>
</div><!-- fragment --><p>they write</p>
<div class="fragment"><div class="line">RUN_ALL_TESTS();</div>
</div><!-- fragment --><p>This is <b>wrong and dangerous</b>. The testing services needs to see the return value of <span class="tt">RUN_ALL_TESTS()</span> in order to determine if a test has passed. If your <span class="tt">main()</span> function ignores it, your test will be considered successful even if it has a GoogleTest assertion failure. Very bad.</p>
<p>We have decided to fix this (thanks to Michael Chastain for the idea). Now, your code will no longer be able to ignore <span class="tt">RUN_ALL_TESTS()</span> when compiled with <span class="tt">gcc</span>. If you do so, you'll get a compiler error.</p>
<p>If you see the compiler complaining about you ignoring the return value of <span class="tt">RUN_ALL_TESTS()</span>, the fix is simple: just make sure its value is used as the return value of <span class="tt">main()</span>.</p>
<p>But how could we introduce a change that breaks existing tests? Well, in this case, the code was already broken in the first place, so we didn't break it. :-)</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
My compiler complains that a constructor (or destructor) cannot return a value. What's going on?</h1>
<p>Due to a peculiarity of C++, in order to support the syntax for streaming messages to an <span class="tt">ASSERT_*</span>, e.g.</p>
<div class="fragment"><div class="line">ASSERT_EQ(1, Foo()) &lt;&lt; <span class="stringliteral">&quot;blah blah&quot;</span> &lt;&lt; foo;</div>
</div><!-- fragment --><p>we had to give up using <span class="tt">ASSERT*</span> and <span class="tt">FAIL*</span> (but not <span class="tt">EXPECT*</span> and <span class="tt">ADD_FAILURE*</span>) in constructors and destructors. The workaround is to move the content of your constructor/destructor to a private void member function, or switch to <span class="tt">EXPECT_*()</span> if that works. This <a href="advanced.md#assertion-placement">section</a> in the user's guide explains it.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md100"></a>
My SetUp() function is not called. Why?</h1>
<p>C++ is case-sensitive. Did you spell it as <span class="tt">Setup()</span>?</p>
<p>Similarly, sometimes people spell <span class="tt">SetUpTestSuite()</span> as <span class="tt">SetupTestSuite()</span> and wonder why it's never called.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md101"></a>
I have several test suites which share the same test fixture logic; do I have to define a new test fixture class for each of them? This seems pretty tedious.</h1>
<p>You don't have to. Instead of</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FooTest : <span class="keyword">public</span> BaseTest {};</div>
<div class="line"> </div>
<div class="line">TEST_F(FooTest, Abc) { ... }</div>
<div class="line">TEST_F(FooTest, Def) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BarTest : <span class="keyword">public</span> BaseTest {};</div>
<div class="line"> </div>
<div class="line">TEST_F(BarTest, Abc) { ... }</div>
<div class="line">TEST_F(BarTest, Def) { ... }</div>
</div><!-- fragment --><p>you can simply <span class="tt">typedef</span> the test fixtures:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> BaseTest FooTest;</div>
<div class="line"> </div>
<div class="line">TEST_F(FooTest, Abc) { ... }</div>
<div class="line">TEST_F(FooTest, Def) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> BaseTest BarTest;</div>
<div class="line"> </div>
<div class="line">TEST_F(BarTest, Abc) { ... }</div>
<div class="line">TEST_F(BarTest, Def) { ... }</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md102"></a>
GoogleTest output is buried in a whole bunch of LOG messages. What do I do?</h1>
<p>The GoogleTest output is meant to be a concise and human-friendly report. If your test generates textual output itself, it will mix with the GoogleTest output, making it hard to read. However, there is an easy solution to this problem.</p>
<p>Since <span class="tt">LOG</span> messages go to stderr, we decided to let GoogleTest output go to stdout. This way, you can easily separate the two using redirection. For example:</p>
<div class="fragment"><div class="line">$ ./my_test &gt; gtest_output.txt</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
Why should I prefer test fixtures over global variables?</h1>
<p>There are several good reasons:</p>
<ol type="1">
<li>It's likely your test needs to change the states of its global variables. This makes it difficult to keep side effects from escaping one test and contaminating others, making debugging difficult. By using fixtures, each test has a fresh set of variables that's different (but with the same names). Thus, tests are kept independent of each other.</li>
<li>Global variables pollute the global namespace.</li>
<li>Test fixtures can be reused via subclassing, which cannot be done easily with global variables. This is useful if many test suites have something in common.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
What can the statement argument in ASSERT_DEATH() be?</h1>
<p><span class="tt">ASSERT_DEATH(statement, matcher)</span> (or any death assertion macro) can be used wherever <em><span class="tt">statement</span></em> is valid. So basically <em><span class="tt">statement</span></em> can be any C++ statement that makes sense in the current context. In particular, it can reference global and/or local variables, and can be:</p>
<ul>
<li>a simple function call (often the case),</li>
<li>a complex expression, or</li>
<li>a compound statement.</li>
</ul>
<p>Some examples are shown here:</p>
<div class="fragment"><div class="line"><span class="comment">// A death test can be a simple function call.</span></div>
<div class="line">TEST(MyDeathTest, FunctionCall) {</div>
<div class="line">  ASSERT_DEATH(Xyz(5), <span class="stringliteral">&quot;Xyz failed&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or a complex expression that references variables and functions.</span></div>
<div class="line">TEST(MyDeathTest, ComplexExpression) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> c = Condition();</div>
<div class="line">  ASSERT_DEATH((c ? Func1(0) : object2.Method(<span class="stringliteral">&quot;test&quot;</span>)),</div>
<div class="line">               <span class="stringliteral">&quot;(Func1|Method) failed&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Death assertions can be used anywhere in a function.  In</span></div>
<div class="line"><span class="comment">// particular, they can be inside a loop.</span></div>
<div class="line">TEST(MyDeathTest, InsideLoop) {</div>
<div class="line">  <span class="comment">// Verifies that Foo(0), Foo(1), ..., and Foo(4) all die.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {</div>
<div class="line">    EXPECT_DEATH_M(Foo(i), <span class="stringliteral">&quot;Foo has \\d+ errors&quot;</span>,</div>
<div class="line">                   <a class="code hl_class" href="classtesting_1_1_message.html">::testing::Message</a>() &lt;&lt; <span class="stringliteral">&quot;where i is &quot;</span> &lt;&lt; i);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A death assertion can contain a compound statement.</span></div>
<div class="line">TEST(MyDeathTest, CompoundStatement) {</div>
<div class="line">  <span class="comment">// Verifies that at lease one of Bar(0), Bar(1), ..., and</span></div>
<div class="line">  <span class="comment">// Bar(4) dies.</span></div>
<div class="line">  ASSERT_DEATH({</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {</div>
<div class="line">      Bar(i);</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  <span class="stringliteral">&quot;Bar has \\d+ errors&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclasstesting_1_1_message_html"><div class="ttname"><a href="classtesting_1_1_message.html">testing::Message</a></div><div class="ttdef"><b>Определения</b> gtest-message.h:101</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
I have a fixture class <span class="tt">FooTest</span>, but <span class="tt">TEST_F(FooTest, Bar)</span> gives me error <span class="tt">"no matching function for call to `FooTest::FooTest()'"</span>. Why?</h1>
<p>GoogleTest needs to be able to create objects of your test fixture class, so it must have a default constructor. Normally the compiler will define one for you. However, there are cases where you have to define your own:</p>
<ul>
<li>If you explicitly declare a non-default constructor for class <span class="tt"><a class="el" href="class_foo_test.html">FooTest</a></span> (<span class="tt">DISALLOW_EVIL_CONSTRUCTORS()</span> does this), then you need to define a default constructor, even if it would be empty.</li>
<li>If <span class="tt"><a class="el" href="class_foo_test.html">FooTest</a></span> has a const non-static data member, then you have to define the default constructor <em>and</em> initialize the const member in the initializer list of the constructor. (Early versions of <span class="tt">gcc</span> doesn't force you to initialize the const member. It's a bug that has been fixed in <span class="tt">gcc 4</span>.)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md106"></a>
Why does GoogleTest require the entire test suite, instead of individual tests, to be named <span class="tt">*DeathTest</span> when it uses <span class="tt">ASSERT_DEATH</span>?</h1>
<p>GoogleTest does not interleave tests from different test suites. That is, it runs all tests in one test suite first, and then runs all tests in the next test suite, and so on. GoogleTest does this because it needs to set up a test suite before the first test in it is run, and tear it down afterwards. Splitting up the test case would require multiple set-up and tear-down processes, which is inefficient and makes the semantics unclean.</p>
<p>If we were to determine the order of tests based on test name instead of test case name, then we would have a problem with the following situation:</p>
<div class="fragment"><div class="line">TEST_F(FooTest, AbcDeathTest) { ... }</div>
<div class="line">TEST_F(FooTest, Uvw) { ... }</div>
<div class="line"> </div>
<div class="line">TEST_F(BarTest, DefDeathTest) { ... }</div>
<div class="line">TEST_F(BarTest, Xyz) { ... }</div>
</div><!-- fragment --><p>Since <span class="tt">FooTest.AbcDeathTest</span> needs to run before <span class="tt">BarTest.Xyz</span>, and we don't interleave tests from different test suites, we need to run all tests in the <span class="tt"><a class="el" href="class_foo_test.html">FooTest</a></span> case before running any test in the <span class="tt">BarTest</span> case. This contradicts with the requirement to run <span class="tt">BarTest.DefDeathTest</span> before <span class="tt">FooTest.Uvw</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md107"></a>
But I don't like calling my entire test suite <span class="tt">*DeathTest</span> when it contains both death tests and non-death tests. What do I do?</h1>
<p>You don't have to, but if you like, you may split up the test suite into <span class="tt"><a class="el" href="class_foo_test.html">FooTest</a></span> and <span class="tt">FooDeathTest</span>, where the names make it clear that they are related:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FooTest : <span class="keyword">public</span> <a class="code hl_class" href="classtesting_1_1_test.html">::testing::Test</a> { ... };</div>
<div class="line"> </div>
<div class="line">TEST_F(FooTest, Abc) { ... }</div>
<div class="line">TEST_F(FooTest, Def) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FooDeathTest = FooTest;</div>
<div class="line"> </div>
<div class="line">TEST_F(FooDeathTest, Uvw) { ... EXPECT_DEATH(...) ... }</div>
<div class="line">TEST_F(FooDeathTest, Xyz) { ... ASSERT_DEATH(...) ... }</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md108"></a>
GoogleTest prints the LOG messages in a death test's child process only when the test fails. How can I see the LOG messages when the death test succeeds?</h1>
<p>Printing the LOG messages generated by the statement inside <span class="tt">EXPECT_DEATH()</span> makes it harder to search for real problems in the parent's log. Therefore, GoogleTest only prints them when the death test has failed.</p>
<p>If you really need to see such LOG messages, a workaround is to temporarily break the death test (e.g. by changing the regex pattern it is expected to match). Admittedly, this is a hack. We'll consider a more permanent solution after the fork-and-exec-style death tests are implemented.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md109"></a>
The compiler complains about &lsquo;no match for 'operator&lt;&lt;&rsquo;` when I use an assertion. What gives?</h1>
<p>If you use a user-defined type <span class="tt">FooType</span> in an assertion, you must make sure there is an <span class="tt">std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const FooType&amp;)</span> function defined such that we can print a value of <span class="tt">FooType</span>.</p>
<p>In addition, if <span class="tt">FooType</span> is declared in a name space, the <span class="tt">&lt;&lt;</span> operator also needs to be defined in the <em>same</em> name space. See <a href="https://abseil.io/tips/49">Tip of the Week #49</a> for details.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md110"></a>
How do I suppress the memory leak messages on Windows?</h1>
<p>Since the statically initialized GoogleTest singleton requires allocations on the heap, the Visual C++ memory leak detector will report memory leaks at the end of the program run. The easiest way to avoid this is to use the <span class="tt">_CrtMemCheckpoint</span> and <span class="tt">_CrtMemDumpAllObjectsSince</span> calls to not report any statically initialized heap objects. See MSDN for more details and additional heap check/debug routines.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md111"></a>
How can my code detect if it is running in a test?</h1>
<p>If you write code that sniffs whether it's running in a test and does different things accordingly, you are leaking test-only logic into production code and there is no easy way to ensure that the test-only code paths aren't run by mistake in production. Such cleverness also leads to <a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbugs</a>. Therefore we strongly advise against the practice, and GoogleTest doesn't provide a way to do it.</p>
<p>In general, the recommended way to cause the code to behave differently under test is <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>. You can inject different functionality from the test and from the production code. Since your production code doesn't link in the for-test logic at all (the <a href="https://docs.bazel.build/versions/master/be/common-definitions.html#common.testonly"><span class="tt">testonly</span></a> attribute for BUILD targets helps to ensure that), there is no danger in accidentally running it.</p>
<p>However, if you <em>really</em>, <em>really</em>, <em>really</em> have no choice, and if you follow the rule of ending your test program names with <span class="tt">_test</span>, you can use the <em>horrible</em> hack of sniffing your executable name (<span class="tt">argv[0]</span> in <span class="tt">main()</span>) to know whether the code is under test.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md112"></a>
How do I temporarily disable a test?</h1>
<p>If you have a broken test that you cannot fix right away, you can add the <span class="tt">DISABLED_</span> prefix to its name. This will exclude it from execution. This is better than commenting out the code or using <span class="tt">#if 0</span>, as disabled tests are still compiled (and thus won't rot).</p>
<p>To include disabled tests in test execution, just invoke the test program with the <span class="tt">--gtest_also_run_disabled_tests</span> flag.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md113"></a>
Is it OK if I have two separate <span class="tt">TEST(Foo, Bar)</span> test methods defined in different namespaces?</h1>
<p>Yes.</p>
<p>The rule is <b>all test methods in the same test suite must use the same fixture class</b>. This means that the following is <b>allowed</b> because both tests use the same fixture class (<span class="tt"><a class="el" href="classtesting_1_1_test.html">testing::Test</a></span>).</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>foo {</div>
<div class="line">TEST(CoolTest, DoSomething) {</div>
<div class="line">  SUCCEED();</div>
<div class="line">}</div>
<div class="line">}  <span class="comment">// namespace foo</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>bar {</div>
<div class="line">TEST(CoolTest, DoSomething) {</div>
<div class="line">  SUCCEED();</div>
<div class="line">}</div>
<div class="line">}  <span class="comment">// namespace bar</span></div>
</div><!-- fragment --><p>However, the following code is <b>not allowed</b> and will produce a runtime error from GoogleTest because the test methods are using different test fixture classes with the same test suite name.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>foo {</div>
<div class="line"><span class="keyword">class </span>CoolTest : <span class="keyword">public</span> <a class="code hl_class" href="classtesting_1_1_test.html">::testing::Test</a> {};  <span class="comment">// Fixture foo::CoolTest</span></div>
<div class="line">TEST_F(CoolTest, DoSomething) {</div>
<div class="line">  SUCCEED();</div>
<div class="line">}</div>
<div class="line">}  <span class="comment">// namespace foo</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>bar {</div>
<div class="line"><span class="keyword">class </span>CoolTest : <span class="keyword">public</span> ::testing::Test {};  <span class="comment">// Fixture: bar::CoolTest</span></div>
<div class="line">TEST_F(CoolTest, DoSomething) {</div>
<div class="line">  SUCCEED();</div>
<div class="line">}</div>
<div class="line">}  <span class="comment">// namespace bar</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
